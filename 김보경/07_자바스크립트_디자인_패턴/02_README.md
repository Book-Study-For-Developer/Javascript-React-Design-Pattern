### 07-17. 행위 패턴

> 행위 패턴은 객체 간의 의사소통을 돕는 패턴입니다.
> 시스템 내 서로 다른 객체 간의 의사소통 방식을 개선하고 간소화하는 것을 목적으로 합니다.

#### 자바스크립트의 행위 패턴들

- 관찰자 패턴
- 중재자 패턴
- 커맨드 패턴

### 07-18. 관찰자 패턴 (Observer)

> 관찰자 패턴은 한 객체가 변경될 때 다른 객체들에 변경되었음을 알릴 수 있게 해주는 패턴입니다. 변경된 객체는 누가 자신을 구독하는지 알 필요 없이 알림을 보낼 수 있습니다.

하나 이상의 관찰자들이 주체의 상태에 관심을 가지고 자신들을 주체에 알림 등록합니다. 관찰자가 관심을 가질만한 변경사항이 주체에서 일어났을 경우, 각 관찰자들의 업데이트에서 메서드를 실행시키는 알림 메세지가 전송됩니다. 관찰자가 더 이상 주체의 변경에 관심이 없어지면 간단히 자신을 알림에서 해제할 수 있습니다. -`GoF의 디자인 패턴`-

자바스크립트 DOM 이벤트 구독이 대표적이지 않을까?

```js
// 버튼 요소 (Subject)
const button = document.getElementById("myButton");

// 첫 번째 이벤트 리스너 (Observer 1)
function handleClick1() {
  console.log("버튼이 클릭되었습니다! - 리스너 1");
}

// 두 번째 이벤트 리스너 (Observer 2)
function handleClick2() {
  console.log("버튼이 클릭되었습니다! - 리스너 2");
}

// Observer를 Subject에 등록(구독)
button.addEventListener("click", handleClick1);
button.addEventListener("click", handleClick2);

// 나중에 Observer 구독 취소
button.removeEventListener("click", handleClick2);
```

#### 07-18.01. 관찰자 패턴과 발행/구독 패턴의 차이점

- 사실 실전에서는 발행/구독 패턴이라는 변형된 형태의 구현이 더 널리 사용되어 오고 있는중이다.
- 두 패턴이 유사한것 같지만 주목할 만한 차이점 또한 존재한다.

  - 관찰자 패턴에서는 이벤트 발생에 대해 알림을 받기 원하는 관찰자 객체가 이벤트를 발생시키는 주체 객체에 알림 대상으로서 등록되어야 합니다.

    - > 해석: 어떤 변화나 사건(이벤트)가 일어났을 때 관찰자는 먼저 그 변화가 일어나는 객체(주체)에게 미리 알려달라고 등록을 해놓아야 함

  - 반면 발행/구독 패턴에서는 이벤트 알림을 원하는 구독자와 이벤트를 발생시키는 발생자 사이에 토픽/이벤트 채널을 둡니다. 이로 인해 앱에서는 특화된 이벤트를 정의할 수 있고, 구독자에게 필요한 값이 포함된 커스텀 인자를 전달할 수 있습니다.
    - > 해석: 이벤트 발생지와 이벤트 알림을 원하는 구독자 사이에 이벤트 채널이 존재함. 이로인해 앱에서는 여러 종류의 이벤트를 만들 수 있게 되고 구독자들에게 필요한 정보를 커스텀해서 보낼 수 있음.ㄴ

- 발행/구독 패턴의 핵심은 발행자와 구독자를 각자 독립적으로 유지한다는 것입니다.
- 또한 시스템의 구성 요소 간에 느슨할 결합을 도모한다는 것입니다.
- 객체(발행자)가 다른 객체(구독자)의 메서드를 직접 호출하는 대신, 구독자는 특정 작업이나 활동을 구독하고 해당 작업이나 활동이 발생했을 때 알림을 받게 됩니다.

> AuthGuard 컴포넌트에서 로그인 상태를 구독하고 전역 스토어에서 로그인 상태에 따른 이벤트 채널 역할을 해주는게 비슷한 예시인가...?

#### 장단점.

- 모듈 등 여러 구성 요소 간의 관계에서 직접 연결되어있는 부분을 파악하여 주체과 관찰자로 대체할 수 있도록 도와주고 이는 결국 애플리케이션을 더 작고 느슨하게 연결된 부분으로 나눌 수 있게 도와주고, 결과적으로 코드의 관리와 재사용성을 높일 수 있습니다.
- 클래스를 강하게 결합시키지 않으면서 관련 객체들 사이의 일관성 유지 가능
- 반면, 결합도가 낮은 분리된 특성으로 인해 제대로 동작하는지에 대해 명확히 파악하기 어렵고 의존성을 추적하기 어려울 수 있음.

#### Ajax 기반 jQuery 애플리케이션 결합도 낮추기

- Ajax를 사용하는 애플리케이션에서는 req에 대한 res 로직에 하나의 동작이 아닌 복합적인 구성을 하는 경우가 많습니다.
- 요청 성공 시에 실행되는 롤백에 후속 로직을 넣을 수도 있지만, 단점도 존재합니다.
  - 모듈 간 높은 결합도를 가진 애플리케이션은 코드 사이에 의존성이 증가하여 재사용하기 어려워짐.
- 관찰자 패턴을 사용한다면 애플리케이션 전반에 걸쳐 발생하는 다양한 이벤트의 알림을 원하는 만큼 자세한 수준으로 분리할 수 있음.
  - Ajax 레이어는 req, res동작만 할 수 있도록 구성할 수 있으며, 반환된 데이터는 어떻게 처리할지 구독자에게 맡기는 구조.

### 07-19. 중재자 패턴

> 중재자 패턴은 하나의 객체가 이벤트 발생 시 다른 여러 객체들에게 알림을 보낼 수 있는 디자인 패턴입니다.

- 중재자 패턴은 하나의 객체가 다른 객체에서 발생한 특정 유형의 이벤트에 대해 알림을 받을 수 있습니다.
- 시스템의 여러 부분이 통신할 수 있는 통합 인터페이스를 제공합니다.
- JS에서는 DOM 이벤트 버블링과 이벤트 위임을 예시로 들 수 있음.
  - 시스템의 모든 이벤트 등록이 일어날 개별 DOM 노드 대신 최상위 Document 를 대상으로 했을 경우 Document 객체는 사실상 중재자 역할을 하게 됨.
    (이벤트가 발생하는 Document 객체가 개별 노드에 알려주는 방식)

#### 07-19.2. 이벤트 집합 패턴과의 유사점과 차이점

##### 이벤트 관점

- 이벤트 집합 패턴은 이벤트를 이름에서도 명확히 알 수 있듯 이벤트를 다루는 패턴임.
- 반면 중재자 패턴은 JS 웹 또는 프레임웨크에서 구현을 단순화 하기 위해 이벤트를 사용함.
  - 중재자 패턴은 반드시 이벤트를 다룰 필요가 없음. 객체에 대한 참조를 하위 객체에 전달

> 두 패턴이 왜 이벤트를 사용하는지에 대해 차이점이 존재함. 이벤트 집합은 그 자체로 이벤트를 처리하기 위한 목적으로 설계된 패턴이지만, 중재자 패턴은 단순히 편리하기 때문에 이벤트를 활용합니다.

##### 서드 파티 객체의 관점

- 설계상, 이벤트 집합 패턴과 중재자 패턴 모두 상호작용을 간소화하기 위해 서드 파티 객체를 사용함.
  - 이벤트 집합 패턴 자체는 이벤트 발행자와 구독자에 대해 서드 파티 객체이며, 모든 이벤트가 통과하는 중앙 허브의 역할을 수행함.
  - 중재자 패턴 또한 다른 객체에 대한 서드 파티 객체 역할을 수행함.
- 구분을 하기위해서는 로직과 워크플로가 어디에 구현되어 있는지 파악이 필요함
  - 이벤트 집합 패턴에서 서드 파티 객체는 알 수 없는 수의 소스에서 알 수 없는 수의 핸들러로 이벤트가 연결되도록 지원하는 역할만 수행함.
    - 실행되어야 하는 모든 워크플로와 비즈니스 로직은 이벤트를 발생시키는 객체와 처리하는 객체(핸들러)에 직접 구현되는 방식
  - 중재자 패턴에서는 비즈니스 로직과 워크플로는 중재자 내부에 집중이 되는 구조로 되어있음.
    - 중재자는 자신이 보유한 정보를 바탕으로 각 객체의 메서드 호출 시점과 속성 업데이트 필요성을 판단. 이를 통해 프로세스를 캡슐화하고 여러 객체 사이를 조율하여 시스템을 원하는대로 동작할 수 있도록 만들어줌.
    - 중재자는 보다 거시적인 차원에서 결정을 통해 객체들에 적절한 작업 시기를 알려주게 됨.

##### 알잘딱 사용하기 위해서는?

- 두 패턴의 유사점과 차이점의 이해부터 시작할 수 있음.
- 책에서는 그냥 알잘딱 쓰라고하는데...
- GPT에 물어봤습니다!
  - 중재자 패턴이 더 적절한 상황
    - 복잡한 비즈니스 규칙이 존재할 때
    - 상태 일관성이 필요할 때
    - 상호작용이 양방향이고 즉각적인 반응이 필요할 때
  - 이벤트 패턴이 더 적절한 상황
    - 시스템이 확장 가능하고 구성 요소가 동적으로 추가/제거될 때
    - 비동기 통신이 주요 패턴일 때
    - 시스템이 느슨하게 결합되어야 하고 컴포넌트가 서로에 대해 알 필요가 없을 때
    - 일대다(One-to-Many) 통신 패턴이 주요할 때

#### 07-19.5. 이벤트 집합 패턴(발행/구독)과 중재자 패턴 결합하기

> 두 패턴이 왜 혼용되면 안되는지에 대한 이해하기 위해서는 두 패턴을 함께 사용해 보는 것이 가장 효과적입니다.

혼용되면 안된다고 써놓고 왜 연동해서 사용하는 두 패턴의 결합 예시를 제공해 주었을까

- 이벤트 집합 패턴을 통해 워크플로 사이의 명확한 분리를 구현. 중개자 패턴을 통해 워크플로의 관리 및 유지보수성을 강화.

> #### 두 패턴의 의도적인 결합과 개선 가능성
>
> 책에서 언급하는 "결합을 통한 유의미한 개선"은 두 패턴을 무분별하게 혼용하는 것이 아니라, 각 패턴의 강점을 활용하여 계층적으로 구조화하는 접근법을 의미할 가능성이 높습니다.

##### 이러한 계층적 결합의 이점

1. 관심사 분리 강화

- 중재자: 밀접하게 연관된 객체 그룹 내부의 복잡한 통신 처리
- 이벤트 패턴: 큰 기능 영역 간의 느슨한 통신 처리

2. 모듈성 향상

- 각 기능 모듈은 자체 중재자를 가질 수 있음
  모듈 간 통신은 이벤트 패턴으로 처리

3. 디버깅 용이성

- 문제를 모듈 내부(중재자) 또는 모듈 간(이벤트) 통신으로 빠르게 분류 가능

4. 확장성과 견고성의 균형

- 중재자의 견고한 통신 관리와 이벤트 패턴의 유연한 확장성을 동시에 확보

예시로는 Redux + React 사례를 예시로 제공해주었음. === 회사 소스코드에 있는 패턴!

#### 07-19.6. 최신 JS에서 중재자 패턴과 미들웨어

- Express.js 서버 프레임워크에서는 사용자가 접근할 수 있는 특정 경로(end point 의미하는듯)에 콜백 함수(server action인듯)를 추가할 수 있습니다
- '/'경로에 접근할 때 해당 요청에 headers룰 추가 구성하는 경우, 미들웨어를 사용해 쉽게 구현 가능
- next() 메서드를 통해 req / res 사이클의 다음 콜백 함수를 호출할 수 있음. req와 res 사이에 미들웨어를 구성함으로써 요청과 응답 간 흐름 제어 가능

#### 07-19.7. 중재자 패턴 vs 퍼사드 패턴

> 두 패턴 모두 기존 모듈의 기능을 추상화하지만 미묘한 차이점이 존재합니다.

- 중재자 패턴은 모듈이 명시적으로 중재자를 참조함으로써 모듈 간의 상호작용을 중앙집중화 합니다.
  - 다방향적으로 모듈간 상호작용 가능한 형태인듯
- 퍼사드 패턴은 모듈 또는 시스템에 직관적인 인터페이스를 제공하지만 추가 기능을 구현하지는 않습니다.
  - 시스템 내 다른 모듈은 퍼사드의 개념처럼 퍼사드ed된 모듈을 직접적으로 인지하지 못하므로 단방향의 구조를 띄고있게 됨

### 07-20. 커맨드 패턴

> 커맨드 Command 패턴은 메서드 호출, 요청 또는 작업을 단일 객체로 캡슐화하여 추후에 실행할 수 있도록 해줍니다.
> 이를 통해 실행 시점을 유연하게 조정하고 호출을 매게변수화 할 수도 있습니다.
> 커맨드 패턴은 명령을 실행하는 객체와 명령을 호출하는 객체 간의 결합을 느슨하게 하여 구체적인 클래스(객체)의 변경에 대한 유연성을 향상시킵니다.

- 추상 클래스를 상속받아 필요한 기능을 모두 구현한 클래스를 구체 클래스라고 합니다.
  - 추상클래스는 인터페이스를 제공하지만 모든 멤버 함수의 구현을 제공하지 않습니다.
- 커맨드 패턴의 기본 원칙은 명령을 내리는 객체와 명령을 실행하는 객체의 책임을 분리한다는 것입니다.
  - 커맨드 패턴에서는 이러한 책임을 다른 객체에 위임함으로써 역할을 분리할 수 있습니다.
  - 구현 측면에서 단순 커맨드 객체는 `실행할 동작`과 `해당 동작을 호출할 객체`를 연결합니다.
    > - 해석: "누가 명령을 요청하는가" 그리고 "누가 명령을 실행하는가" 라는 두 가지 다른 책임을 분리해주는 듯

```js
const CarManager = {
  // 정보 조회
  requestInfo(model, id) {
    return `The information for ${model} with ID ${id} is foobar`;
  },

  // 자동차 구매
  buyVehicle(model, id) {
    return `You have successfully purchased Item ${id}, a ${model}`;
  },

  // 시승 신청
  arrangeViewing(model, id) {
    return `You have booked a viewing of ${model} (${id})`;
  },
};

// 구현하고자 하는 기능
CarManager.execute("buyVehicle", "Ford Escort", "453543");

// 구현하고자 하는 기능에 맞추어 메서드 정의 추가
carManager.execute = function (name) {
  return (
    carManager[name] &&
    carManager[name].apply(carManager, [].slice.call(arguments, 1))
  );
};
```

### 07-21. 마치며

- 이번 장에서는 생성, 구조, 행위 패턴을 적절하게 조합하여 class, object, module 설계 시 활용할 수 있는 디자인 패턴에 대해서 다루었습니다.
- 또한 다른 OOP 언어에서 사용되던 패턴들을 자바스크립트 환경에 맞추어 적용해 보았습니다.
