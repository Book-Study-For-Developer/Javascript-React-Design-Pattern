## 12. 리액트 디자인 패턴

### 12-01. 리액트 소개

- 프론트엔드 개발자들은 대부분 웹 인터페이스 설계에 대해 관심이 많습니다. === 유즈케이스 설계 혹은 UI/UX, 사실 AI의 발전으로 직군간 경계가 많이 허물어지고 있는것 같습니다.
- 리액트(와 유사한)는 인터페이스를 표현하는 최적화 및 간소화된 방법을 제공합니다.
- 또한 인터페이스를 컴포넌트, Props, 상태라는 세가지 핵심 개넘으로 나누어 정리함으로써 복잡하고 까다로운 인터페이스를 쉽게 구축할 수 있습니다.
- 리액트를 효과적으로 활용하려면 모듈화된 사고방식이 필요합니다. === 객체지향형 프로그래밍과 유사한점이 존재함으로써 캡슐화 등이 가능하기 때문인걸까
  - 명시적으로 객체라고 표현하여 사용하지는 않지만, "데이터와 상태와 행위를 그룹핑한 것" 이라는 객체지향에서 이야기하는 객체의 개념으로 본다면 리액트에서 각 구성요소들은 OOP 관점으로 볼 수 있지 않을까..? SOLID원칙이 Frontend에서도 적용될 수 있는 이유이기도 하고... 개인적인 견해입니다.
- 페이지나 뷰를 구성하기 전에 개별 컴포넌트를 먼저 개발하도록 하기에, 각 컴포넌트의 역할과 목적을 확실히 할 수 있습니다. === 컴포넌트화 지이잉

#### 리액트 용어 소개

- ReactDOM: 클라이언트와 서버 렌더링에서 DOM에 특화된 메서드를 제공하는 react-dom ㅍㅐㅋㅣㅈㅣ
- JSX: HTML과 유사한 구조로 UI요소를 정의할 수 있게 해주는 JS의 문법 확장
- 리덕스🤢
- Hooks: 클래스 컴포넌트가 아니더라도 state와 기타 리액트의 기능들을 사용할 수 있게 해주는 기능 Good bye HOC

#### 리액트의 기본 개념

- JSX
  : JSX는 XML과 유사한 구문을 사용하여 HTML을 자바스크립트에서 사용할 수 있게 해주는 확장 문법입니다.
  JSX는 구현 방식에 따라 특정한 모습을 가지지만 결과적으로 자바스크립트로 변환됩니다.

- 컴포넌트
  : 컴포넌트는 리액트의 기본 구성 요소입니다.
  어떠한 입력값(Props)을 받아서 화면에 표시할 내용을 나타내는 리액트의 요소를 반환하는 함수하고 보시면 됩니다.
  기본적으로 리액트는 컴포넌트 안에 또 다른 컴포넌트가 중첩되는 구조라고 볼 수 있습니다.
  컴포넌트는 UI를 독립적이고 재사용 가능한 조각으로 나눌 수 있게 해줍니다.

- Props
  : Props는 Properties의 줄임말로, 리액트 컴포넌트의 내부 데이터를 의미합니다. (상태라고 표현하는게 알맞지 않을까)
  props의 두가지 주요 특징

  1. props 값은 컴포넌트가 만들어지기 전에 미리 결정되고 컴포넌트 설계의 일부로 사용됩니다.
  2. props 값은 바꿀 수 없습니다. 컴포넌트로 전달되고 나면 읽기 전용이 됩니다. 이후엔 this.props 속성을 통해 props에 접근할 수 있습니다.

- 상태
  : 상태는 컴포넌트의 라이프사이클 동안 값이 변할 수도 있는 정보를 담고 있는 객체입니다.
  또한 컴포넌트가 받아온 props의 현재 상태를 나타내기도 합니다.

- CSR, SSR
  : 최근 회사에서 redis를 사용해서 마크업 생성 server action을 캐싱해버리자 하는 이야기가 있었는데 redis가 유료화가 되면서 후순위로 미뤄져버렸습니다. 혹시 redis 병행해서 사용해보신분 계실까요?
  react remix로 경험해보는 ssr도 궁금하네요 :)

- Hydration
  : 서버에서 미리 생성한 상호작용이 불가능한 스켈레톤 마크업에 상호작용이 가능하도록 클라이언트에서 자바스크립트 번들이 로드되고 처리되는 일련의 과정.
  리액트는 현재의 DOM 노드를 검사하고, 해당 자바스크립트와 연결하여 활성화, 즉 하이드레이트 합니다.

### 12-02. 고차 컴포넌트 HOC

- 고차 컴포넌트는 다른 컴포넌트를 인자로 받아 새로운 컴포넌트를 반환하는 컴포넌트 입니다.
- 고차 컴포넌트는 특정 기능을 포함하고 있어, 이 기능을 매개변수로 전달받은 컴포넌트에 적용할 수 있습니다.

사실 고차 컴포넌트를 직접 구현한 경험이 얼마 없네요.
최근에는 지양하는 패턴으로 알고있습니다.
backend 코드에서 withConnect라는 함수로 controller를 감싼 형태로 DB 연결상태를 확인하는 핸들러 함수가 제가 사용해본 예시인거같습니다 :)

```js
export const createUser = withConnect(
  async (input: 대충인풋타입): Promise<대충아웃풋타입> => {
    // 유저 생성...
  }
);
```

### 12-03. 렌더링 Props 패턴

- 렌더링 이라는 Prefix가 붙어있는걸 보면 렌더링 Props를 주입받는 컴포넌트는 view 역할만 맡아서 수행하여야 하고, 데이터를 주입해주는 컴포넌트 그리고 view만을 책임지는 컴포넌트 등의 역할이 명확이 나누어진 구조가 개인적으로 좋은거같습니다.

#### 상태 끌어올리기

- 컴포넌트가 자신의 상태를 다른 컴포넌트와 공유하려면, 상태를 필요로 하는 컴포넌트와 가장 가까운 공통 부모 컴포넌트로 끌어올려야 합니다. === 상태 끌올

#### 장점

- Props를 명시적으로 전달함으로써, 요소에 전달해야 할 props는 모두 렌더링 prop의 인자 목록에 명확하게 나타나므로 어떤 props가 어디에서 오는지 정확하게 파악 가능합니다.
- 또한 렌더링 prop을 통해 애플리케이션 로직과 렌더링 컴포넌트를 분리할 수 있습니다.
- 렌더링 prop을 통해 상태를 가진 컴포넌트는 데이터를 상태로 가지지 않은 컴포넌트로 전달하고, 해당 컴포넌트는 그저 데이터를 렌더링하는 역할을 하게 됩니다.

#### 단점

- 렌더링 prop에는 라이프사이클 관련 메서드를 추가할 수 없으므로, 받은 데이터를 변경할 필요가 없는 렌더링에 치중한 컴포넌트에만 사용할 수 있습니다.

### 12-04. 리액트 Hooks 패턴

- Hooks 자체는 디자인 패턴이라고 할 수 없지만, 애플리케이션 설계에서 중요한 역할을 합니다. Hooks를 사용하면 클래스 컴포넌트를 사용하지 않고도 상태와 라이프사이클 메서드를 활용할 수 있습니다.

#### 클래스 컴포넌트

> 먼저 클래스 컴포넌트가 어떻게 상태와 라이프사이클 메서드를 사용할 수 있었는지 살펴보겠습니다. :)

- Hooks가 도입되기 이전에는 컴포넌트에 상태와 라이프사이클 메서드를 추가하려면 클래스 컴포넌트를 사용해야 했습니다.

```js
class MyComponent extends React.Component {
 // state 추가 및 커스텀 메서드 바인딩
 constructor() {
   super();
   this.state = { ... };

   this.customMethodOne = this.customMethodOne.bind(this);
   this.customMethodTwo = this.customMethodTwo.bind(this);
 }

 // 라이프사이클 메서드
 componentDidMount() { ... }
 componentWillUnmount() { ... }

 // 커스텀 메서드
 customMethodOne() { ... }
 customMethodTwo() { ... }

 render() { return { ... }}
}
```

##### 클래스 컴포넌트는 다음과 같은 특징을 갖고있습니다.

- 생성자 함수 내의 상태
- 컴포넌트의 라이프사이클에 따른 효과를 처리하기 위한 componentDidMount, componentWillUnmount와 같은 라이프사이클 메서드
- 추가적인 로직을 구현하기 위한 커스텀 메서드

Hooks의 도입 이후에도 클래스 컴포넌트를 사용할 수 있지만, 몇 가지 단점이 존재합니다.

- 라이프사이클을 직접 관리한다는 관점에서 엄청난 복잡도 존재
- 깊게 중첩된 컴포넌트 구조 === "래퍼 헬" 이 발생할 수 있음
- 클래스 컴포넌트에 로직이 추가될수록 컴포넌트의 크기는 빠르게 증가함.

#### Hooks

- Hooks를 사용하면 컴포넌트의 상태와 라이프사이클 메서드를 관리할 수 있습니다.
- 함수형 컴포넌트에 상태 추가하기
- componentDidMount, componentWillUnmount 같은 라이프사이클 메서드를 사용하지 않고도 컴포넌트의 라이프사이클 관리하기
- 여러 컴포넌트 간에 동일한 상태 관련 로직 재사용하기

### 12-05. 상태 Hook

- 리액트는 함수형 컴포넌트 내에서 상태를 관리하는 useState라는 Hook을 제공합니다.
- useState 메서드에서 두 가지 값을 추출할 수 있습니다
  - 현재 상태 값
  - 상태를 업데이트하는데 사용할 수 있는 메서드 === dispatcher..?

#### 이펙트 Hook

- useEffect를 사용하면 컴포넌트의 라이프사이클에 접근할 수 있습니다.
- useEffect는 componentDidMount, componentDidUpdate, componentWillUnmount 라이프사이클 메서드를 하나로 합쳐 사용할 수 있습니다.

```js
componentDidMount() { ... }
useEffect(() => { ... }, [])

componentWillUnmount() { ... }
useEffect(() => { return () => { ... } }, [])

componentDidUpdate() { ... }
useEffect(() => { ... }, [ ... ])
```

#### 커스텀 Hook

최근에는 useOptimistic 이런것도 봤었던것 같네요
사용해본 Hooks 모듈은 이정도인거같아요

- [useHooks-ts](https://usehooks-ts.com/)
- [react-simplekit](https://react-simplikit.slash.page/ko/)

책에서 이런내용도 다루어주었다면 더 좋았을거같네요
[[번역] useEffect를 남용하지 마세요!](https://velog.io/@typo/leave-useeffect-alone)

### 12-08. 코드 스플리팅

- Lazy-load와 suspense를 사용하면 필요한 번들만 먼저 로딩하도록 설정이 가능합니다
  - 클라이언트 페이지 로딩시간을 개선하는데 사용하기도 하지만, server side에서 굳이 생성하지 않아도 되는 모듈을 따로 분리시키는데에도 사용해봤네요

### 12-09. PRPL 패턴

> Push Render Pre-cache Lazy-load

- 저사양 기기나 인터넷이 불안정한 지역에서도 애플리케이션이 원할하게 작동하게 만들어야 하는 쉽지 않은 과제가 존재합니다. === 구형 브라우저에서 지원하지 않는 메서드를 지원하기 위해 폴리필로 Prototype에 직접 메서드를 작성해주는 이유이기도 하죠...
- 어려운 환경에서도 애플리케이션이 최대한 효율적으로 로드될 수 있도록 PRPL 패턴을 사용할 수 있습니다.
- PRPL은 패턴은 네가지 핵심 성능 고려사항에 중점을 둡니다.
  - push: 중요한 리소스를 효율적으로 푸시하여 서버 왕복 횟수를 최소화하고 로딩 시간을 단축합니다.
  - 렌더링: 사용자 경험을 개선하기 위해 초기 경로를 최대한 빠르게 렌더링합니다.
  - pre-cache: 자주 방문하는 경로의 asset을 백그라운드에서 미리 캐싱하여 서버 요청 횟수를 줄이고 더 나은 오프라인 경험을 제공합니다.
  - 지연 로딩: 자주 요청되지 않는 경로나 에셋은 지연로딩 합니다.
