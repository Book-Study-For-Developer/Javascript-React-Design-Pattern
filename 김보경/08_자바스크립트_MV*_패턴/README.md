## 08. 자바스크립트 MV\* 패턴

> ### [들어가며]
>
> 애플리케이션 설계에는 객체의 설계와 애플리케이션 아키텍처라는 두 가지 중요한 측면이 있습니다.
> 앞 장에서는 객체의 설계와 관련된 패턴을 살펴 보았다면 이번 장에서는 3가지 기본 아키텍처 패턴인 MVC, MVP, MVVM 을 살펴볼 것입니다.

- MVC: 모델 - 뷰 - 컨트롤러 (model view controller)
- MVP: 모델 - 뷰 - 프리젠터 (model view presenter)
- MVVM: 모델 - 뷰 - 뷰모델 (model view viewModel)

### 08-1. MVC 패턴

> MVC 패턴은 애플리케이션의 구조를 개선하기 위해 관심사의 분리를 활용하는 아키텍처 디자인 패턴입니다. 비즈니스 데이터(Model)와 UI(View)를 분리하고, 세 번째 구성 요소(Controller)가 로직과 사용자 입력을 관리하는 구조입니다.

#### 08-1.1. Smalltack-80 의 MVC 패턴

**먼저 기존의 MVC 패턴이 목표로 했던 문제점을 이해하는것이 중요합니다.**

- 초기 Smalltack-80 에서 구현된 MVC 아키텍처에는 주목할만한 특징이 존재했습니다.
  - Model: 도메인 관련 데이터를 표현하였으며 View에 대해서는 관여하지 않았습니다. 모델이 변경되면 자신의 관찰자(Oberver)객체에게 알림을 보냈습니다.
  - View: 모델의 현재 상태를 표현했습니다. 관찰자 패턴을 사용해 모델이 변경되거나 수정될 때마다 View가 알아차릴 수 있도록 했습니다. 또한 뷰는 화면에 보여지는 프레젠테이션 부분만을 담당했지만, 화면에 표시되는 각 섹션 또는 요소에는 언제나 View - Controller 쌍이 존재했습니다.
  - Controller: 키보드 입력이나 클릭 같은 상호작용을 처리하고 View에 무엇을 보여줄지, 사용자의 입력을 어떻게 처리할지 등을 결장하는 역할을 했습니다.

### 08-2. 자바스크립트의 MVC

> 현재의 자바스크립트 또한 MVC 또는 다른 MV\* 패턴을 지원하는 여러 프레임워크를 갖추고 있어, 쉽게 MVC 패턴을 사용해 볼 수 있습니다.

#### 모델

- 모델은 애플리케이션의 데이터를 관리하는 역할을 합니다.
- UI나 프레젠테이션은 계층은 담담하지 않고, 애플리케이션에 필요한 고유 데이터 형식을 나타냅니다.
- 모델이 변경될 때 관찰자에게 변경사항을 알려 관찰자가 변경된 내용에 알맞게 대응할 수 있도록 합니다.

#### 뷰

- 뷰는 모델에 대한 시각적인 표현으로, 현재 상태의 특정 부분만 보여줍니다.
  - JS의 뷰는 여러 DOM 요소의 집합을 생성하고 정리하는 역할.
- 일반적으로 뷰는 모델을 관찰하고, 모델에 변화가 생기면 알림을 받습니다.
- 사용자는 뷰와 상호작용할 수 있습니다. 데이터를 읽고 수정하는 기능도 포함. === 모델 수정 혹은 편집을 용이하게 할 수도 있음.
- 모델을 실제로 업데이트하는 작업은 컨트롤러가 담당

#### 템플릿

- 템플릿 리터럴에 대한 내용인듯?

- 템플릿 자체는 뷰가 아닙니다.
- 템플릿은 뷰 객체의 일부 또는 전체를 선언적으로 지정하는 방법이 될 수 있습니다.
- 템플릿은 템플릿 리터럴과 같은 기법으로 애플리케이션에서 HTML을 깔끔하고 유지보수에 용이한 방식으로 만들어 줌.

#### 컨트롤러

- 컨트롤러는 모델과 뷰 사이의 중재자 역하을 하며, 일반적으로 사용자가 뷰를 조작할 때 모델을 업데이트 하는 역할을 합니다.
- 컨트롤러는 애플리케이션 내에서 모델과 뷰 간의 로직 그리고 연동을 관리합니다.

### 08-3. MVC를 사용하는 이유는?

- 관심사 분리로 애플리케이션의 기능을 더 간단한 모듈로 나눌 수 있도록 해줍니다.
  - 전반적인 유지보수의 단순화: 애플리케이션을 업데이트 해야 할 때, 변경사항이 데이터 중심인지 아니면 시각적인 변경인지 명확히 구분 가능
  - 모델과 뷰의 분리: 비즈니스 로직에 대한 단위 테스트 작성이 용이해짐
  - 애플리케이션 전반에서 하위 수준의 모델 및 컨트롤러 코드 중복 제거
  - 애플리케이션의 규모와 역할 분리 정도에 따라서 모듈화된 로직을 서로 다른 책임을 가진 작업자가 동시에 작업을 수행할 수 있도록 함

### 08-6. MVP 패턴

> MVP 패턴은 프레젠테이션 로직의 개선에 초점을 맞춘 MVC 디자인 패턴의 파생입니다.

- MVC 그리고 MVP 모두 여러 구성 요소 간의 관심사 분리를 목표로 하지만, 몇 가지 근본적인 차이점이 있습니다.

#### 모델, 뷰, 프리젠터

> MVP 에서 P는 Presenter를 의미합니다. Presenter는 View에 대한 UI 비즈니스 로직을 담당하는 구성 요소입니다.

- MVP에서는 MVC와는 다르게 View에서의 이벤트 호출은 Presenter로 위임됩니다.
- Presenter는 View와 분리되어 있으며, 인터페이스를 통해 View와 통신합니다.
  - 해당 방식은 든위 테스트에서 View를 Mocking할 수 있는 등의 장점이 있습니다.
- 컨트롤러와 프리젠터는 서로 다른 역할을 갖고 있습니다.
  - 프리젠터는 모델을 관찰하고 모델이 변경될 때 뷰를 업데이트 합니다.
  - 이는 MVC에서 컨트롤러가 담당하던 역할입니다.
- 뷰에서의 요청에 따라 프리젠터는 사용자 요청과 관련되 작업을 수행하고 데이터를 뷰로 다시 전달합니다.
  - 이를 위해서 프리젠터는 데이터를 가져오고, 조작하고, 데이터가 어떻게 뷰에 표시되어야 하는지 결정합니다.
  - 일부 구현에서는 프리젠터가 모델에 데이터를 저장하기 위해 서비스 계층과 상호작용 하기도 합니다.
- 모델이 이벤트를 발생시킬 수도 있지만, 이벤트를 구독하여 뷰를 업데이트 할 수 있도록 하는 것이 프리젠터의 역할입니다.

MVC에서 MVP로의 변화는 애플리케이션의 테스트 용이성을 높이고 뷰와 모델 간의 분리를 더욱 명확하게 해줍니다. 하지만 MVP 패턴에는 데이터 바인딩이 지원되지 않기 때문에, 작업을 별도로 처리해야 하는 비용이 발생할 수 있습니다.

#### MVP vs MVC (가슴이 웅장해진다)

- MVP는 일반적으로 프레젠데이션 로직을 최대한 재사용해야 하는 엔터프라이즈 수즌의 애플리케이션에서 사용됩니다. 뷰가 매우 복잡하고 사용자와의 상호작용이 많은 애플리케이션에서는 MVC가 적합하지 않을 수 있습니다.
  - 이런 문제를 MVC로 해결하려면 여러 컨트롤러에 크게 의존해야 할 수 있기 때문입니다.
  - MVP에서는 이 모든 복잡한 로직을 프리젠터 안에 캡술화 할 수 있어 유지보수가 간단해집니다.
- MVP의 뷰는 인터페이스를 통해 정의되고, 인터페이스가 시스템과 뷰(프리젠터 제외)간의 유일한 접점이므로, 이 패턴을 사용하면 개발자는 디자이너가 애플리케이션의 레이아웃과 그래픽을 완성하기를 기자리지 않고도 프레젠테이션 로직을 작성할 수 있습니다.

하지만 MVC와 MVP 간의 차이점이 대부분 의미론적인 수준이므로, MVC에 존재하는 근본적인 문제점들도 MVP에 동일하게 존재할 가능성이 큽니다. 그러므로 모델, 뷰, 컨트롤러 혹은 프리젠터로 관심사를 명확히 분리하기만 한다면, 어떤 패턴을 선택하여도 대부분 동일한 장점을 얻을 수 있을것입니다.

### 08-7. MVVM 패턴

> MVVM 패턴은 MVC와 MVP를 기반으로 하는 아키텍처 패턴으로, 애플리케이션의 UI 개발 부분과 비즈니스 로직, 동작 부분을 명확하게 분리합니다.

- MVVM 방식은 선언적 데이터 바인딩을 활용하여 뷰에 대한 작업을 다른 계층과 분리할 수 있도록 합니다.
- 계층 분리로 인하여 동일한 코드베이스 안에서 서로 다른 계층의 작업을 동시에 진행 가능

MVVM은 세가지 구성요소로 이루어져 있습니다.

- 모델: 도메인에 관련된 정보 전달
- 뷰: 사용자 인터페이스 (UI)
- 뷰모델: 모델과 뷰 사이의 인터페이스 역할을 합니다.

#### 뷰모델

> 뷰모델은 데이터 변환기의 역할을 하는 특수한 컨트롤러로 볼 수 있습니다. 모델의 정보를 뷰가 사용할 수 있는 형태로 변환하고, 뷰에서 발생한 명령(조작이나 이벤트)을 모델로 전달합니다.

- 뷰모델은 뷰라기 보다는 모델에 더 가깝다고 볼 수 있습니다. 그러나 동시에 부의 디스플레이 로직 대부분을 처리하게 됩니다.
- 뷰모델은 뷰의 상태를 유지하고, 뷰에서 발생한 동작에 기반해 모델을 업데이트하며, 뷰에 이벤트를 발생시키는 등의 기능을 수행하기 위한 메서드도 제공할 수 있습니다.

정리해보면, 뷰모델은 UI 계층의 뒤에 위치합니다. 뷰가 필요로하는 데이터를 모델로부터 가져와 제공하며, 데이터와 사용자의 동작 모두를 뷰가 참조하는 출처의 역할을 수행합니다.

#### 장단점

##### 장점

- MVVM은 UI와 이를 구동하게 해주는 요소를 동시에 개발할 수 있도록 합니다.
- MVVM은 뷰를 추상화함으로써 뷰 뒤에 작성되는 비즈니스 로직의 양을 줄여줍니다.
- 뷰모델은 이벤트 중심 코드에 비해 단위 테스트가 더 쉽습니다.
- 뷰모델은 UI 자동화나 상호작용에 대한 고려 없이도 테스트가 가능합니다.

##### 단점

- 단순한 UI의 경우, MVVM은 과도한 구현이 될 수 있습니다 (오버 엔지니어링!!!)
- 데이터 바인딩은 선언적이고 사용하기 편리할 수 있지만, 단순히 중단점(breakPoints)을 설정하는 명령형 코드에 비해 디버깅이 더 어려울 수 있습니다.
- 복잡한 애플리케이션에서는 데이터 바인딩이 상당한 관리 부담을 만들어 낼 수 있습니다.
- 대규모 애플리케이션에서는 필요한 일반화를 제공하기 위해 뷰모델을 미리 설계하는 것이 어려울 수 있습니다.

#### MVC vs MVP vs MVVM (삼파전)

> MVP와 MVVM은 모두 MVC에서 파생된 패턴입니다.
> MVC와 파생 패턴들 사이의 차이점은 각 계층이 다른 계층에 대해 갖는 의존성과, 서로 얼마나 강하게 연결되어 있는지에 있습니다.

- MVC에서는 뷰가 아키텍처 최상단에 위치하고 그 옆에는 컨트롤러가 있습니다. 모델은 컨트롤러 아래에 있기 때문에, 뷰는 컨트롤러에 대해 알고, 컨트롤러는 모델에 대해 알고 있습니다. 해당 구조에서 뷰는 모델에 직접 접근할 수 있지만 전체 모델이 뷰에 노출되는것은 보안 및 성능에 문제를 야기할 수 있으므로 MVVM 패턴을 사용해서 회피할 수 있습니다.
- MVP에서는 컨트롤러의 역할이 프리젠터로 대체됩니다. 프리젠터는 뷰와 동일한 계층에 존재하며, 뷰와 모델 양쪽에서 발생하는 이벤트를 수신하고 동작을 조정합니다. MVVM과는 달리, 뷰와 뷰모델을 바인딩하는 메커니즘이 없기 때문에, 각 뷰는 프리젠터가 뷰와 상호작용할 수 있도록 인터페이스를 구현합니다.

결과적으로, MVVM을 사용하면 상태와 로직 정보를 포함할 수 있는 뷰와 관련된 모델 일부를 생성할 수 있습니다. 이를 통해 전체 모딜을 뷰에 노출하는 것을 피할 수 있습니다.
MVP의 프리젠터와 달리 뷰모델은 뷰를 참조할 필요가 없으며 뷰는 뷰모델의 속성을 바인딩하여 모델에 포함된 데이터를 뷰에 표현할 수 있습니다. 또 뷰가 추상화되기 때문에 뷰에 필요한 로직의 양이 줄어듭니다.

그러나!
이러한 뷰와 뷰모델 분리의 단점은 둘 사이에 일정 수준의 변환이 필요해 성능에 영향을 줄 수 있다는 점입니다. 뷰에 표시하기 위한 데이터를 조작하는 복잡한 과정이 존재할 수도 있습니다.
MVC에서는 모델 전체에 바로 접근 가능한 구조이므로 MVVM같은 성능 문제가 발생하지 않습니다.

#### 최신 MV\* 패턴

- 기술적으로 React나 Vue와 같은 최신 라이브러리와 프레임워크는 애플리케이션의 뷰 또는 프레젠테이션 계층을 구성합니다.
- 그리고 대부분의 경우에 이 프레임워크들은 모델 구현 방식과 애플리케이션의 상태 관리에 대해 유연합니다.
  - 공식적으로 Vue는 뷰모델을 사용하는 MVVM패턴이라고 주장합니다.
  - React 에서는 MV\* 패턴에 대한 추가적인 고려사항이 존재합니다.

##### MV\* 패턴과 React

분명히 말하면, React는 MVC 프레임워크가 아닙니다. 리액트는 UI구축을 위한 자바스크립트 라이브러리 입니다.

- 리액트는 백엔드에서 사용되는 MVC 패턴과 잘 맞지 않기 때문에 MVC로 분류되지 않습니다.
  - 리액트는 뷰 계층을 구성하게 해주는 렌더링 라이브러리 입니다. MVC 와 같이 중앙 제어 역할을 하는 컨트롤러 혹은 라우터 기능이 포함되어 있지 않습니다.
- 리액트는 선언형 프로그래밍 방식을 따릅니다. 개발자는 애플리케이션이 원하는 상태를 기술하고, 리액트는 그 상태를 기반으로 적절한 뷰를 렌더링하게 됩니다.
  - 리액트에서는 서버가 브라우저에 뷰를 직접 제공하지 않고 데이터를 제공하게 됩니다. 리액트에서는 데이터를 브라우저 구문에서 분석하여 실제 뷰를 생성합니다. 이러한 관점에서 리액트을 뷰라고 할 수는 있지만, 전통적인 의미에서는 아닙니다.
