## 11. 네임스페이스 패턴

> #### [들어가며]
>
> 네임스페이스는 코드 단위를 고유한 식별자로 그룹화한 것을 뜻합니다.
> 하나의 식별자를 여러 네임스페이스에서 참조할 수 있고, 각 식별자는 중첩된(혹은 하위) 네임스페이스의 계층구조를 가질 수 있습니다.

- 대규모 스크립트나 애플리케이션에서는 네임스페이스가 매우 중요합니다.
- 다른 스크립트와 변수 또는 메서드 이름이 충돌하여 코드가 실행되지 않는 문제를 방지하기 위함
- 자바스크립트는 다른 언어들처럼 네임스페이스를 기본적으로 지원하지는 않지만, 객체와 클로저를 활용하여 비슷한 효과를 얻을 수 있습니다.

### 11-01. 네임스페이스의 기초

- 네임스페이스 패턴의 종류
  - 단일 전역 변수
  - 접두사 네임스페이스
  - 객체 리터럴 표기법
  - 중첩 네임스페이스
  - 즉시 실행 함수 표현식
  - 네임스페이스 주입

### 11-02. 단일 전역 변수 패턴

- 자바스크립트에서 널리 사용되는 네임스페이스 패턴 중 하나는, 하나의 전역 변수를 주요 참조 객체로 사용하는 방식입니다.

```js
const myUniqueApplication = (() => {
  function myMethod() {
    // 코드
    return;
  }

  return {
    myMethod,
  };
})();

// 사용법
myUniqueApplication.myMethod(); // `myUniqueApplication` 에서 외부로 노출된
// `myMethod()` 호출

// 이번 예시에서는 즉시 실행 함수 표현식(IIFE)을 통해 애플리케이션만의
// 고유한 네임스페이스를 생성하고, 이를 myUniqueApplication 변수에 담고 있습니다.
// IIFE는 함수와 속성을 가진 객체를 반환하고,
// 이 객체에 접근 가능(예: myUniqueApplication.myMethod())을 사용해서
// 접근할 수 있습니다.
```

클로저를 활용하는거같은데... 외부로 반환된 method는 외부로 노출된 이후에도 렉시컬 스코프에 접근 가능한 구조

- 단일 전역 변수 패턴은 특정한 상황에서는 유용할 수 있지만, 이미 같은 이름의 전역 변수가 사용되어 충돌이 발생할 수 있습니다.

### 11-03. 접두사 네임스페이스 패턴

- 단일 전역 변수 문제에 대한 해결책 중 하나는 접두사 네임스페이스 패턴을 활용하는 것 입니다.
- 기본 개념으로는 먼저 고유한 접두사를 선언한 다음 모든 메서드, 변수, 객체를 해당 접두사 뒤에 붙여서 정의하면 됩니다.

```js
const product_modal_A = {};
const product_modal_B = {};
function product_open() {
  // overlay-kit은 신이다...
}
```

Prefix라는 단어 뜻 그대로 명확한 목적을 붙혀주는듯

> tmi
> 저희는 next fullstack 특성상 네임스페이스가 오염되는경우가 빈번해서 type 사용시에는 interface사용은 지양하면서 type의 T- 를 주로 붙혀 사용하고 있습니다
> ex) TUser, TProduct 등등

### 11-04. 객체 리터럴 표기법 패턴

- 객체 리터럴 표기법은 일종의 객체로, 키와 값으로 이루어진 집합을 가지며, 각각의 키와 값은 콜른(:)으로 구분됩니다.
- 또한 키 자체가 새로운 네임스페이스가 될 수 있습니다.

```js
const endPoints = {
  service: {
    getService: "api/service/getService",
  },
  user: {
    getUser: (id) => `api/user/getUser/${id}`,
  },
  modules: {},

  // 등등 저는 이런 패턴으로 자주 사용중입니다
};
```

- 객체 리터럴 표기법 패턴은 전역 네임스페이스를 오염시키지 않으면서 코드와 매개변수를 구성하는데 도움을 줍니다.
- 쉽게 읽을 수 있고, 깊은 중첩까지 지원하는 구조를 구현할때 유용
- 동일한 이름의 번수가 있는지 검사하도록 설계되는 경우가 많아 충돌 가능성을 크게 줄여줍니다.
- 객체 리터럴의 장점은 키-값 구조이기에 손쉽게 알아 볼 수 있습니다.
- 서로 다른 로직이나 기능을 쉽게 캡슐화하여 깔끔하게 분리할 수 있습니다.

> ##### [아하 모먼트 😮]
>
> JSON은 사실 객체 리터럴 표기법의 서브셋이며, 문법적으로 약간의 차이만 있습니다. (예를들면 JSON에서 Key는 문자열 이어야 합니다.)

### 11-05. 중첩 네임스페이스 패턴

- 객체 리터럴 패턴을 발전시킨 형태가 바로 중첩 네임스페이스 패턴 입니다.
- 중첩 네임스페이스 패턴은 다른 패턴에 비해 충돌 위험이 낮은 패턴입니다.

```js
const myApp = myApp || {};

// 중첩된 하위 속성을 정의할 때에도 비슷한 방법으로 객체 존재 여부를 확인합니다.
myApp.routes = ayAppp.routes || {};
myApp.model = ayAppp.model || {};
myApp.model.special = ayAppp.model.special || {};

// 필요에 따라 중첩 네임스페이스를 복잡하게 만들 수 있습니다.
// myApp.utilities.charting.html5.plotGraph(/*...*/);
// myApp.modules.financePlanner.getSummary();
// myApp.services.social.facebook.realtimeStream.getLatest();

// ---

// 다음과 같이 새로은 중첩 네임스페이스/속성을 인덱싱된 속성으로 선언할 수도 있습니다.
myApp["routers"] = myApp["routers"] || {};
myApp["models"] = myApp["models"] || {};
myApp["controllers"] = myApp["controllers"] || {};
```

- 해당 패턴에서 주의할 점은, 브라우저의 자바스크립트 엔진이 먼저 myApp 객체의 위치를 찾은 후, 실제로 사용하고자 하는 함수가 위치한 곳까지 파고들어가야 한다는 것입니다.

### 11-06. 즉시 실행 함수 표현식 패턴

> 즉시 실행 함수 표현식
> Immediately Invoked Function Expressions
> 줄여서 **IIFE**..!
> 즉시 실행 함수는 정의 직후 바로 실행되는, 이름이 없는 함수입니다.

- 자바스크립트에서는 즉시 실행 함수로 정의된 내부의 변수와 함수 모드 외부에서 접근할 수 없습니다.
- 따라서 함수를 호출하는 것만으로도 쉽게 코드의 은닉성을 구현할 수 있습니다.
- 즉시 실행 함수는 애플리케이션의 로직을 캡슐화하여 전역 네임스페이스로부터 보호하는데 널리 사용되는 방법입니다.

> 클로저 은닉을 이야기하는거같은데... 스코프 체인, 렉시컬스코프 환경 어쩌구~~

```js
// 즉석에서 호출되는 (익명의) 함수 표현식
(() => {
  /*...*/
})();

// 이름이 있는 즉시 실행 함수 표현식
(function foobar() {
  /*...*/
})();

// 문법적으로는 자기 실행 함수지만 앞의 예시들과는 꽤 다릅니다.
function foobar() {
  foobar();
}
```

1. 익명 즉시실행 함수

- 익명: 함수 이름이 없음
- 즉시 실행: 정의와 동시에 한 번만 실행
- 스코프 격리: 내부 변수가 전역 스코프를 오염시키지 않음
- 일회성: 재호출 불가능

2. 이름이 있는 즉시실행 함수

- 명명됨: 함수 내부에서 자기 자신을 참조 가능 (재귀)
- 즉시 실행: 정의와 동시에 한 번만 실행
- 스코프 격리: 동일하게 격리됨
- 디버깅: 스택 트레이스에서 함수명 확인 가능

3. 일반 함수 호출 (아주아주 크리티컬한 차이가 있습니다)

- 전역 선언: foobar가 전역 스코프에 등록됨
- 무한 재귀: 호출하면 무한 루프 발생 (Stack Overflow)
- 재사용 가능: 외부에서 foobar() 호출 가능
- 의도적 설계 아님: 실제로는 버그를 유발하는 패턴

```js
// 1. 모듈 초기화 (권장)
(() => {
  const privateConfig = "설정값";
  // 초기화 로직
  console.log("앱 초기화 완료");
})();

// 2. 재귀가 필요한 즉시 실행 (특수한 경우)
(function processTree(node) {
  console.log(node.value);
  node.children?.forEach((child) => processTree(child));
})(rootNode);

// 3. 잘못된 패턴 (절대 사용 금지)
function infiniteLoop() {
  infiniteLoop(); // 💥 스택 오버플로우
}

// 세번째의 경우는 안티패턴으로, 실제 코드에서는 반드시 피해야 할 구조라고 합니다.
// 사실 저는 즉시실행 함수를 직접 작성해서 사용해본 경험이 없는거같아요 :)
```

### 11-07. 네임 스페이스 주입 패턴

- 네임스페이스 주입 패턴은 즉시 실행 함수 패턴의 또 다른 변형입니다.
- 이 패턴에서는 함수 내에서 this를 네임스페이스의 프록시로 활용하여 특정 네임스페이스에서 메서드와 속성을 **주입** 합니다.
- 네임스페이스 주입 패턴의 장점은 여러 객체나 네임스페이스에 기능적인 동작을 쉽게 적용할 수 있다는 점입니다. 또한 이후 확장될 기본 메서드(ex: getter, setter)에 적용할 때 유용합니다.
- 단점으로는 같은 목적을 달성하는 더 쉽고 효율적인 방법(ex: 심층 객체 확장 또는 병합)이 존재할 수도 있다는 것입니다. === 오버엔지니어링을 말하는건가 비교적 리소스가 많이드는 작업인듯 합니다.

```js
const myApp = myApp || {};
myApp.utils = {};

(function () {
  let val = 5;

  this.getValue = () => val;

  this.setValue = (newVal) => {
    val = newVal;
  };

  // utils 하위에 새로운 하위 네임스페이스인 tools를 생성합니다.
  this.tools = {};
}).apply(myApp.utils);

// 위에서 utils를 통해 정의한 tools 네임스페이스에 새로운 동작을 추가합니다.

(function () {
  this.diagnose = () => "diagnosis";
}).apply(myApp.utils.tools);

// 주의: 일반적인 즉시 실행 함수에도 이 확장 기법을 적용할 수 있습니다.
// context를 인자로 받아서 'this' 대신 해당 context를 직접 수정하면 됩니다.

// 사용법:

// 생성된 네임스페이스 구조를 출력
console.log(myApp);

// 출력: 5
console.log(myApp.utils.getValue()); // 5를 출력

// 'val' 값을 변경하고 반환합니다.
myApp.utils.setValue(25);
console.log(myApp.utils.getValue());

// 심층 단계를 테스트합니다.
console.log(myApp.utils.tools.diagnose());

// 해당 패턴은 봐도 잘 모르겠네요 :(
```

- 이러한 유형의 패턴은 여러 모듈이나 네임스페이스에 비슷한 기본 기능들을 할당할 때 유용합니다.
- 하지만 객체/클로저 내에서 명시적으로 기능을 선언할 때 직접 접근하는 것이 불가능한 상황에서만 사용하는 것을 추천드립니다.

### 11-08. 고급 네임스페이스 패턴

> 이제부터 대규모 애플리케이션을 개발할 때 유용한 고급 패턴과 유틸리티를 살펴보겠습니다.

#### 11-08.01. 중첩 네임스페이스 자동화 패턴

- 앞서 살펴본 중첩 네임스페이스는 코드에 체계적이고 계층적인 구조를 만들어줍니다.

```js
// 우리는 중첩 네임스페이스이 객체 리터럴 패턴을 사용하여 다음과 같은 확장된 구조를 구성할 수도 있습니다.
const application = {
  utilities: {
    drawing: {
      canvas: {
        paint: {
          //...
        },
      },
    },
  },
};
```

- 해당 패턴의 한 가지 명백한 단점은, 추가하고자 하는 계층이 늘어날수록 더 많은 하위 객체들이 정의되어야 한다는 점입니다.

  - 특히 복잡한 대규모 애플리케이션에서는 중첩의 깊이가 커질수록 매우 번거로워질 수 있는 작업입니다.

- 번거로운 문제를 효율적으로 해결할 수 있는, 기존의 전역 변수 하위에 중첩된 네임스페이스를 자동으로 정의하는 방법이 존재합니다.

```js
// 최상위 네임스페이스에 객체 리터럴을 할당합니다.
const myApp = {};

// 문자열 형식의 네임스페이스를 파싱하고
// 자동으로 중첩 네임스페이스를 생성해주는 간편한 함수입니다.
function extend(ns, ns_string) {
  const parts = ns_string.split(".");
  let parent = ns;
  let pl;

  pl = parts.length;

  for (let i = 0; i < pl; i++) {
    // 프로퍼티가 존재하지 않을 경우에만 생성합니다.
    if (typeof parent[parts[i]] === "undefined") {
      parent[parts[i]] = {};
    }

    parent = parent[parts[i]];
  }

  return parent;
}

// 사용법:
// myApp에 깊게 중첩된 네임스페이스를 확장합니다.
const mod = extend(myApp, "modules.module2");

// 올바르게 중첩된 객체를 출력합니다.
console.log(mod);

// mod 인스턴스는 myApp 네임스페이스 밖에서도 확장된
// 클론 객체로 사용할 수 있는지 확인합니다.

// true를 출력합니다.
console.log(mod === myApp.modules.module2);

// extend를 사용하여 더 쉽게 중첩 네임스페이스를 할당하는 또 다른 예시입니다.
extend(myApp, "moduleA.moduleB.moduleC.moduleD");
extend(myApp, "longer.version.looks.like.this");
console.log(myApp);
```

#### 11-08.03. 심층 객체 확장 패턴

- 실전 프로젝트에서 Lodash.js의 extend() 메서드를 사용하는게 더 간단하고 브라우저 호환성도 높다...!

### 마치며

사실 바닐라 자바스크립트에서 사용하는 어떤 고급 방법이나 개념들이 나왔는데... 크게 다가오지는 않았던것 같습니다.
다음장 리액트 디자인 패턴이 조금 더 기대되는 부분이 있지 않나 생각이 드네요
이번주도 고생하셨습니다~@
