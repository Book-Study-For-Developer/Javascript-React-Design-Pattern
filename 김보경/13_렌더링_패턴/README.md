## 13. 렌더링 패턴

#### 렌더링 패턴

- CSR: 실제 클라이언트로 전송되는 HTML은 매우 기본적인 구조만 갖고있으며, JS 번들을 로드하는 script 태그와 렌더링이 될 컨테이너 태크만 존재합니다. 이후 브라우저가 JS 번들을 다운로드하고 실행하면서 DOM API를 통해 실제 HTML요소들이 동적으로 생성됩니다.

- SSR: 서버에서 static HTML을 먼저 생성한 후, 클라이언트에서 JS 번들을 실행하면서 static 마크업에 상호작용이 가능하도록 하이드레이트 처리

- 정적 렌더링: 빌드타임에 서버에서 페이지를 렌더링하여 정적인 사이트를 구축.

- ISR 증분 정적 재생성: SSG방식으로 생성된 페이지에 빌드타임 이후 데이터 변화를 적용하기 위해 데이터에 특정 주기를 설정하여 페이지를 재생성하도록하여 다음 접속 시 새로은 데이터를 반영한 페이지를 사용자에게 전달

- 스트리밍 렌더링: suspense로 각 청크로 분할된 컨테이너를 렌더링하는 개념인듯 합니다.

- 엣지 렌더링

- 하이브리드 렌더링: 빌드타임, SSR 및 CSR을 결합한 형식

- 부분 하이드레이션: 클라이언트에서 일부 컴포넌트만 하이트레이션합니다.
- 점진적 하이드레이션: 클라이언트에서 컴포넌트 하이드레이션 순서를 제어
- 아일랜드 아키텍처: static HTML 안에서 필요한 부분만 JS를 통해 동적으로 동작시키는 아키텍처 패턴
- 점진적 향상: 자바스크립트 없이도 애플리케이션이 작동하도록 보장.

이번 장에서는 다양한 렌더링 패턴을 소개하고, 상황에 따른 적합판 패턴 선택에 도움을 드리고자 합니다. 근본적인 질문에 대해 해답을 찾을 수 있으셨으면 좋겠습니다.

- 콘텐츠를 어디에서 어떻게 렌더링할 것인가?
- 웹 서버, 빌드 서버, edge 네트워크 또는 클라이언트, 이중 어디에서 콘텐츠를 렌더링할 것인가?
- 콘텐츠를 한 번에, 부분적으로, 또는 점진적으로 어떻게 렌더링할 것인가?

### 13-01. 렌더링 패턴의 중요성

#### 좋은 UX를 제공하기 위해, 핵심 웹 지표(Core Web Vitals === CWV)와 같은 사용자 중심 지표를 기준으로 최적화 할 수 있습니다.

- TTFB: Time to First Byte
  클라이언트가 페이지 콘텐츠의 첫 번째 바이트를 받는 데 걸리는 시간
- FCP: First Contentful Paint
  페이지 이동 후 브라우저가 콘텐츠의 첫 부분을 렌더링하는데 걸리는 시간
- TTI: Time to Interactive
  페이지 로드 시작부터 사용자 입력에 빠르게 응답할 수 있을 때까지 걸리는 시간
- LCP: Largest Contentful Paint
  페이지의 주요 콘텐츠를 로드하고 렌더링하는 데 걸리는 시간
- CLS: Cumulative Layout Shift
  예상치 못한 레이아웃 변경을 방지하기 위한 시각적 안정성 측정
- FID: First Input Delay
  사용자가 페이지와 상호작용한 시점부터 이벤트 핸들러가 실행될 수 있는 시점까지의 시간

#### 동시에 좋은 DX를 제공하기 위해서는 빌드 시간 단축, 쉬운 롤백, 학장 가능한 인프라 등 다양한 개발환경 최적화를 진행해야 합니다.

- 빠른 빌드 시간: Turbo pack 만세!
- 낮은 서버 비용: cloudflare 만세!
- 동적 콘텐츠
- 쉬운 롤백
- 안정적인 가동 시간
- 확장 가능한 인프라

각 렌더링 패턴은 특정 사용 사례를 해결하기 위해 설계되었음을 기억해야 합니다.
동일한 웹사이트 내에서도 페이지 유형에 따른 다른 렌더링 패턴이 필요할 수 있습니다.

### 13-02. CSR

- CSR은 페이지의 복잡성이 증가하면 페이지 렌더링에 필요한 JS 코드의 복잡성과 크기도 증가합니다.
- CSR에서 커다란 JS 번들은 페이지의 FCP(First Contentful Paint)와 TTI(Time to Interactive)를 증가시킵니다.
- 또한 크롤러가 색인하기 전에 의미 있는 콘첸트가 렌더링되지 않을 수 있어 웹사이트 SEO에 영향을 미칠 수 있습니다.

### 13-03. SSR

- SSR은 모든 요청마다 HTML을 생성합니다.
  - 사용자 쿠키 정보나 요청 데이터 등 동적으로 맞춤형 데이터를 그려주는 페이지에 가장 적합합니다.
  - 인증 상태에 따라 렌더링 여부를 결정해야 하는 페이지에도 적합합니다.
- SSR의 핵심 원칙은 HTML을 서버에서 렌더링하고 클라이언트에서 다시 하이드레이션하는데 필요한 자바스크립트를 함께 제공하는 것입니다.
  - 하이드레이션에는 비용이 따르기 때문에 SSR은 언제나 하이드레이션 과정을 최적화하려고 합니다.

최근 트렌드는 SEO등 꼭 필요한 경우가 아니라면 서버의 부담을 줄이기 위해 CSR방식을 적용하고 있는것으로 알고있어요. 무분별한 server action은 지양해야한다고 배웠습니다.

### 13-04. SSG

- 서버 구축비용을 아끼고싶어서 Next.js의 export output 기능을 사용해서 빌드파일을 CDN 배포해본적이 있는데, 개인적으로 좋은 경험은 아니었던것 같습니다.
  이미 무의식적으로 사용하고 있는 server component도 많이 존재하고 있었고 최적화도 따라주지 않는 환경이 많이 발생했고,
  Next 자체가 지향하는 방식이 아니다보니 에러처리에 대한 어려움도 몇몇 존재했고, static한 웹사이트 환경 특성상 최근 트렌드와는 충돌하는 기술적 어려움 그리고 SSR 환경이었으면 간편히 구현 가능한 보안처리 등에 대한 리소스가 상당했던 기억이 있습니다 :(

#### 정적 렌더링의 주요 특징

- HTML은 빌드 시점에 생성됩니다.
- CDN 이나 Vercel의 엣지 네트워크를 통해 쉽게 캐싱할 수 있습니다.
- 순수 정적 렌더링은 요청 기반 데이터가 필요하지 않은 페이지에 가장 적합합니다.
- 클라이언트 사이드 데이터 fetching을 통한 정적 렌더링은 매 페이지 로드시 새로고침 되어야 하고, 안정적인 placeholder 컴포넌트에 포홤된 데이터가 있는 페이지에 가장 적합합니다.

#### 13-04.01. 증분 정적 재생성 ISR

- ISR은 정적 렌더링과 SSR을 결합한 방식으로, 특정 정적 페이지만 미리 렌더링하고 동적 페이지는 사용자 요청 시에 on-demand 방식으로 렌더링합니다.
- 이로인해 빌드시간을 단축하며, 특정 시간 간격마다 캐시를 자동으로 무효화하고 페이지를 다시 생성할 수 있습니다.

#### 13-04.02. On-demand ISR

- On- demand ISR은 일반 ISR과 달리, 정해진 시간 간격이 아니라 특정 이벤트 발생 시에 페이지가 재생성됩니다.
- 일반 ISR에서는 업데이트된 페이지가 해당 페이지에 대한 사용자 요청을 처리한 엣지 네트워크 노드에서만 캐시됩니다. 반면 On-demand ISR은 엣지 네트워크 전체에 페이지를 다시 생성하고 재분배하므로, 자동으로 전 세계 사용자가 캐시된 오래된 최신 페이지를 볼 수 있습니다.
- 또한 불필요한 페이지 재생성과 서버리스 함수 호출을 피할 수 있어 일반 ISR에 비해 운영 비용을 절감할 수 있습니다.
- 특정 이벤트에 따라 재생성되어야 하는 페이지에 On-demand ISR을 적용하면 항상 최신 상태를 유지하면서도 합리적인 비용으로 운영 가능합니다.

#### 요약

- 순수 정적 렌더링: 동적인 데이터가 포함되지 않은 페이지에 적합
- 클라이언트 사이드 데이터 fetching을 통한 정적 렌더링: 매 페이지 로드 시 데이터가 새로고침 되어야 하고 안정적인 placeholder 컴포넌트를 가진 페이지에 적합.
- 증분 정적 재생성 ISR: 특정 간격 또는 필요에 따라 재생성되어야 하는 페이지에 적합.
- On-demand ISR: 특정 이벤트 발생 시 재생성되어야 하는 페이지에 적합

### 13-05. Streaming SSR

> SSR이나 정적 렌더링을 사용하면 JS용량을 줄여 페이지가 상호작용 가능해지는 시간(TTI)을 FCP에 더 가깝게 만들 수 있습니다.
> 동시에 스트리밍 방식으로 콘텐츠를 전송하면 애플리케이션을 서버에서 렌더링하면서도 TTI와 FCP를 더욱 단축할 수 있습니다.

- 현재 페이지에 필요한 마크업을 하나의 파일로 구성하는것이 아닌 작은 조각으로 나누어 전송하는 방식
- Node.js의 스트림 기능을 사용하면 응답 객체에 데이터를 스트리밍할 수 있는데, 이는 클라이언트에 데이터를 지속적으로 전송할 수 있음을 의미합니다.
- React에 내장된 renderToNodeStream 함수를 사용하면 애플리케이션을 작은 조각으로 나누어 전송할 수 있습니다.
  - 클라이언트는 데이터를 받는 동시에 UI를 그리기 시작할 수 있으므로 빠른 초기 로딩속도를 제공할 수 있으며, 이렇게 수신된 DOM 노드에 hydrate 메서드를 호출하면 해당 이벤트 핸들러가 연결되어 UI에 상호작용할 수 있게 됩니다.

> 스트리밍 방식은 네트워크가 불안정한 상황에 효과적입니다. 네트워크가 중단된 경우 렌더러는 신호를 받아 네트워크가 복구될 때까지 스트리밍을 중단합니다. 따라서 서버는 메모리를 덜 사용하게 됩니다.
> 이를 통해 Node.js 서버는 여러 요청을 동시에 처리할 수 있으며, 무거운 요청이 가벼운 요청을 장시단 차단하는 것을 방지합니다.
> 결과적으로는 열악한 횐경에서도 사이트는 빠른 응답성을 가질 수 있게 됩니다.

#### 래액트는 16 버전부터 스트리밍을 지원하기 시작했습니다. 스트리밍을 지원하기 위해 ReactDomServer에 다음과 같은 API가 포함되어있습니다.

- ReactDOMServer.renderToNodeStream
  : 이 함수가 만드는 HTML은 ReactDOMServer.renderToString(element)과 동일하지만 문자열 대신 Node.js의 ReadableStream 형식을 사용합니다.
  이 함수는 서버에서만 작동하여 HTML을 스트리밍으로 렌더링합니다.
  스트리밍을 받는 클라이언트는 ReactDOM.hydrate()을 호출하여 상호작용이 가능한 상태로 만들 수 있습니다.
- ReactDOMServer.renderToStaticNodeStream(element)
  이 함수는 ReactDOMServer.renderToStaticMarkup(element)과 비슷합니다.
  다만, 만들어지는 HTML은 동일하지만 스트림 형식입니다.
  따라서 서버에서 정적이고 비상호작용적인 페이지를 렌더링한 다음 클라이언트에 스트리밍 하는 데 사용할 수 있습니다.

두 함수 모두 읽기 시작하면 바이트 단위로 데이터를 보내는 읽기 가능한 스트림(readable stream)을 출력합니다. 이 스트림의 출력을 response 객체와 같은 쓰기 가능한 스트림의 입력으로 연결하면 스트리밍을 구현할 수 있습니다.
이후 response 객체로 새로운 조각이 렌더링되는 동안 클라이언트에 데이터 조각을 지속적으로 전송합니다.

### 13-06. 엣지 SSR

> Edge SSR은 CDN의 모든 지역에서 서버 렌더링을 가능하게 하고, 콜드 부트 시간을 0에 수렴할 수 있도록 해줍니다.

- 엣지 SSR 의 활용 사례로는 사용자별로 지역 특화 리스트 페이지를 구축하는 것을 들 수 있습니다.
  - 페이지의 대부분은 정적 데이터로 구성되고, 리스트 부분만 외부 요청을 통해 데이터를 가져옵니다.
  - 전체 페이지를 SSR로 그리는 대신, 리스트 컴포넌트만 서버사이드에서 렌더링하고 나머지는 엣지 사이드에서 렌더링하도록 선택할 수 있습니다.

### 13-07. 하이브리드 렌더링

- 웹 애플리케이션은 더이상 SPA 또는 MPA로 분류될 필요가 없습니다. 제공되는 기능에 따라 다른 진영으로 쉽게 전환할 수 있습니다.
- 서버가 필요 없는 SPA의 이점을 제공하면서도, 페이지 새로고침 없이 네비게이션할 수 있어 정적 렌더링의 문제를 피할 수 있습니다.
- 리액트 뿐만 아니라 다양한 프레임워크에서도 하이브리드 렌더링을 지원합니다
  - Next.js: 리액트 서버 컴포넌트와 Next.js App router를 결합하여 하이브리드 렌더링이 가능합니다.
    등등...

### 13-08. 점진적 하이드레이션

> 점진적 하이드레이션은 각 노드를 시간에 따라 개별적으로 하이드레이션하여 필요한 최소한의 자바스크립트만 요청하는 방식입니다.
> 상대적으로 중요하지 않은 부분의 하이드레이션을 지연시켜 필요한 JS의 양을 줄이고, 사용자에게 필요한 노드만 하이드레이션 할 수 있습니다.

#### 점진적 하이드레이션 구현을 위한 요구사항

- 모든 컴포넌트에 SSR 사용 가능
- 개별 컴포넌트 또는 조각 단위로 코드 스플리팅 지원
- 개발자가 정의한 순서대로 클라이언트 사이드에서 각 조각 별 하이드레이션 지원
- 이미 하이드레이션된 조각에서 사용자 입력 기능 상태 유지
- 지연된 하이드레이션이 적용되는 조각에 로딩 중임을 표시 가능

리액트의 동시성 모드 기능이 도입되면 이러한 요구사항을 모두 충족할 수 있습니다.

- 동시성 모드는 여러 작업을 동시에 처리하면서도 우선순위에 따라 작업 간 전환을 가능하게 합니다.
- 작업 전환시 부분적으로 렌더링된 트리는 진행을 잠시 멈추어, 다시 동일한 작업으로 돌아왔을 때 이전의 렌더링 작업을 계속할 수 있습니다.

laz(), dynamic import와 suspense를 조합해서 각 조각을 하이드레이션 하는 조각으로 나누고, SusponseList를 통해 지연 로딩되는 컴포넌트의 우선순위를 정의해줌.

### 13-09. 아일랜드 아키텍처

> 아일랜드 아키텍처는 정적은 HTML 위에 독립적으로 전달될 수 있는 상호작용 아일랜드를 통해 자바스크립트의 전송량을 줄이는 패러다임 입니다.
> 또한 정적 그리고 동적 아일랜드로 구분된 페이지 뷰를 제안합니다.

- 아일랜드 아키텍처는 정적 HTML 에 마련된 동적 콘텐츠 자리에 자체적으로 완성된 컴포넌트 위젯을 구성해주는 방식 입니다.
- 각 위젯은 독립적인 애플리케이션처럼 동작하며, 서버에서 렌더링된 결과물과 클라이언트에서 위젯을 활성화하는 데 사용될 자바스크립트 코드를 포함합니다.
- 아일랜드 아키텍처에서는 점진적 하이드레이션과는 반대로 각 컴포넌트가 자체적인 하이드레이션 스크립트를 가지고 있어 페이지의 다른 스크립트와는 다르게 독립적으로 비동기 실행됩니다. 따라서 특정 컴포넌트의 성능 문제가 다른 컴포넌트에 영향을 주지 않습니다.

### 13-10. 리액트 서버 컴포넌트

- 리액트 서버 컴포넌트는 서버에서 실행되도록 설계된 상태를 가지지 않는 리액트 컴포넌트로, 서버 컴포넌트와 클라이언트 컴포넌트 사이의 매끄러운 코드 전환(Knitting)을 가능하게 합니다.
- 기존 SSR방식과는 다르게 클라이언트에서 로드되는 JS 번들의 크기를 크게 줄일 수 있습니다.
- 서버에서 데이터 fetching을 통해 서버 사이드에서 데이터 직렬화를 능하게 하며 새로운 데이터가 있는 경우 다시 렌더링되는 컴포넌트를 가진 애플리케이션을 서버에서 실행할 수 있어 클라이언트로 전송해야 하는 코드 양을 줄일 수 있습니다.
- 서버 컴포넌트는 SSR을 대체하지 않습니다. 함께 사용하면서 서버 컴포넌트의 결과물읠 빠르게 렌더링 시키고, 초기 렌더링 속도를 개선할 수 있습니다.

관련 레퍼런스

- [Rendering Patterns](https://velog.io/@hyunjine/Rendering-Patterns)
