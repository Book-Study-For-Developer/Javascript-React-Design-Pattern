# 8. 자바스크립트 MV* 패턴

## 8.1 MVC 패턴
MVC 패턴은 1979년 트리베 린스카우그가 Smalltalk-80 작업 중 처음 설계했으며, 당시에는 Model-View-Controller-Editor로 불렸습니다. 이후 GoF의 디자인 패턴 책에서 자세히 다뤄지며 널리 알려졌습니다.

### 8.1.1 Smalltalk-80의 MVC 패턴
1970년대에는 GUI가 거의 없었습니다. 실제 세계의 개념을 모델링하는 도메인 객체와, 사용자 화면에 표시되는 프레젠테이션 객체를 명확히 구분하기 위해 '분리된 프레젠테이션' 개념이 등장했습니다. Smalltalk-80의 MVC는 애플리케이션의 로직과 UI를 분리하는 데 중점을 두었습니다.

당시의 MVC
- **모델**: 도메인 관련 데이터를 표현합니다.
- **뷰**: 모델의 현재 상태를 시각적으로 보여줍니다.
- **컨트롤러**: 키보드 입력, 클릭 등 사용자의 상호작용을 처리하고, 뷰에 무엇을 보여줄지, 입력을 어떻게 처리할지 결정합니다.

## 8.2 자바스크립트의 MVC
현재 자바스크립트에는 MVC를 지원하는 다양한 프레임워크가 있습니다. Backbone.js, Ember.js, AngularJS 등이 대표적이며, 최근에는 React, Angular, Vue.js 등에서 MV* 패턴의 다양한 변형이 구현되고 있습니다.

## 8.3 MVC를 사용하는 이유
- 관심사의 분리: 데이터 처리, 화면 표시, 사용자 입력 처리의 책임을 나눠 코드를 더 명확하고 관리하기 쉽게 만들기 위해 필요합니다.
- 유지보수의 단순화: 책임이 나뉘어 있어 각 모듈만 수정하면 되므로 전체 시스템에 영향을 최소화할 수 있습니다.
- 모델과 뷰의 분리: 데이터 로직과 화면 표현이 분리되어 있어 동일한 데이터를 다양한 뷰에서 재사용할 수 있습니다.
- 중복 코드 감소
- 모듈화를 통해 코어 로직과 UI 작업을 분리, 여러 개발자가 동시에 작업 가능: 서로 다른 모듈(모델, 뷰, 컨트롤러)을 서로 간섭 없이 병렬로 개발할 수 있어 협업 효율이 높아집니다.

## 8.5 MV* 패턴의 발전 흐름

MVC 패턴은 소프트웨어 아키텍처에서 관심사의 분리를 대중화한 출발점이었습니다. 하지만 실무에서 사용하다 보니 몇 가지 한계가 드러났습니다. 대표적으로 뷰와 모델이 직접 연결되어 결합도가 높아지고, 컨트롤러의 책임이 점점 비대해지는 문제가 있었습니다.

이러한 한계를 극복하기 위해 다양한 변형 패턴들이 등장했습니다.

### 1. MVC (Model-View-Controller)
- **특징**: 모델, 뷰, 컨트롤러로 역할을 분리하여 관심사의 분리를 실현.
- **한계**: 뷰와 모델이 직접 연결되어 결합도가 높아지고, 컨트롤러가 비대해질 수 있음.

### 2. MVP (Model-View-Presenter)
- **등장 배경**: MVC의 결합도 문제와 테스트 어려움을 해결하기 위해 등장.
- **특징**: 뷰와 모델을 완전히 분리하고, 프리젠터가 중간에서 모든 상호작용을 담당. 뷰는 수동적으로 동작.
- **장점**: 테스트 용이성 증가, 뷰와 프리젠터의 명확한 역할 분리.
- **한계**: 프리젠터가 커지거나, 뷰와 상태 동기화 코드가 많아질 수 있음.

### 3. MVVM (Model-View-ViewModel)
- **등장 배경**: MVP의 프리젠터 비대화와 상태 동기화 부담을 줄이기 위해 등장.
- **특징**: 뷰와 뷰모델 사이에 양방향 데이터 바인딩을 도입, 상태 동기화가 자동화됨.
- **장점**: 뷰와 상태 동기화 부담 감소, 생산성 향상.
- **한계**: 양방향 바인딩이 마법처럼 동작해 상태 추적과 디버깅이 어려울 수 있음.

### 4. MVI (Model-View-Intent)
- **등장 배경**: MVVM의 복잡성과 디버깅 어려움을 해결하고자 등장. Cycle.js, Elm 등 함수형 프로그래밍에서 영감을 받음.
- **특징**: 단방향 데이터 흐름과 불변 상태 관리. 상태 변경 과정을 명확하게 추적 가능.
- **장점**: 예측 가능한 상태 관리, 테스트와 디버깅 용이.
- **한계**: 러닝 커브가 있고, 보일러플레이트 코드가 증가할 수 있음.

#### 참고: Cycle.js와 Elm 아키텍처란?
- **Cycle.js**  
  Cycle.js는 함수형 리액티브 프로그래밍(FRP) 기반의 자바스크립트 프레임워크로, "사용자의 입력(Intent) → 상태(State) → 뷰(View) → 다시 입력"의 순환 구조를 갖습니다. 모든 데이터 흐름이 단방향이며, 애플리케이션을 순수 함수들의 조합으로 모델링합니다. [RxJS](https://www.learnrxjs.io/)를 활용해 스트림 기반으로 UI를 선언적으로 작성할 수 있습니다.

- **Elm 아키텍처**  
  [Elm](https://elm-lang.org/)은 함수형 언어이자, 그 아키텍처는 "Model(상태) - View(화면) - Update(상태변경)"의 구조로 유명합니다. 모든 상태 변경은 명확한 메시지(Intent)를 통해서만 일어나며, 상태는 항상 불변(immutable)입니다. 이 구조는 예측 가능하고, 버그가 적으며, 대규모 애플리케이션에서도 유지보수가 쉽다는 장점이 있습니다.  
  Elm 아키텍처는 Redux, MVI 등 현대 자바스크립트 상태 관리 패턴에 큰 영향을 주었습니다.
```elm
import Browser
import Html exposing (Html, button, div, text)
import Html.Events exposing (onClick)

-- 상태 (Model)
type alias Model = Int

-- 사용자 액션 (Msg)
type Msg = AddOne

-- 초기 상태
init : Model
init = 0

-- 상태 변경 (Update)
update : Msg -> Model -> Model
update msg model =
    case msg of
        AddOne ->
            model + 1

-- 화면 출력 (View)
view : Model -> Html Msg
view model =
    div []
        [ div [] [ text (String.fromInt model) ]
        , button [ onClick AddOne ] [ text "Increment" ]
        ]

-- 프로그램 시작
main =
    Browser.sandbox { init = init, update = update, view = view }
```

> Cycle.js와 Elm 아키텍처 모두 함수형 프로그래밍의 원칙(불변성, 순수 함수, 선언적 UI, 단방향 데이터 흐름 등)을 실무에 적용한 대표적인 사례입니다.  
> MVI 패턴은 이들 아키텍처의 영향을 받아, 복잡한 상태 관리와 예측 가능한 데이터 흐름을 실현하고자 등장했습니다.


최근 프론트엔드 상태 관리의 주류는 Flux 아키텍처를 따르고 있습니다. Flux는 Facebook이 제안한 단방향 데이터 흐름 구조로, Redux, Recoil, Zustand 등 다양한 상태 관리 도구들이 이 아키텍처를 계승하고 발전시켰습니다. MVI 역시 단방향 데이터 흐름을 기반으로 하지만, Cycle.js나 Elm 아키텍처에서 비롯된 함수형 철학에 더 가깝습니다. 실무에서는 Flux 기반의 상태 관리가 도구와 커뮤니티 측면에서 더 많이 채택되고 있습니다.

### Flux 패턴
- **등장 배경**: 대규모 프론트엔드 애플리케이션에서의 복잡한 상태 관리와 데이터 흐름 문제를 해결하기 위해 Facebook에서 제안.
- **특징**: 단방향 데이터 흐름(One-way data flow), Action → Dispatcher → Store → View의 구조. 상태 변경은 오직 Action을 통해서만 발생.
- **장점**: 데이터 흐름이 명확해지고, 상태 추적과 디버깅이 쉬워짐. Redux, Recoil, Zustand 등 다양한 상태 관리 도구의 기반이 됨.
- **한계**: Boilerplate 코드가 많아질 수 있음. Store와 Action의 설계가 복잡해질 수 있음.

> **참고:** MV* 패턴(MVC, MVP, MVVM, MVI 등)을 중심으로 다루고 있으므로, Flux 아키텍처에 대한 상세한 설명은 생략합니다. Flux는 MV* 패턴과는 별도의 계보이지만, 현대 프론트엔드 상태 관리에서 중요한 위치를 차지하므로 간략히 비교 목적으로만 소개하겠습니다!

#### 패턴별 발전 요약

| 패턴   | 등장 이유/해결점                | 주요 특징                        | 한계/다음 패턴 등장 이유      |
|--------|-------------------------------|----------------------------------|-----------------------------|
| MVC    | 관심사 분리, 구조화           | 뷰-모델 직접 연결                | 결합도↑, 컨트롤러 비대화     |
| MVP    | 결합도↓, 테스트 용이성↑       | 프리젠터가 중재                  | 프리젠터 비대화, 동기화 부담 |
| MVVM   | 동기화 자동화, 생산성↑        | 양방향 데이터 바인딩              | 상태 추적/디버깅 어려움      |
| Flux   | 대규모 상태 관리, 데이터 흐름 명확화 | 단방향 데이터 흐름, Action-Dispatcher-Store-View | Boilerplate↑, 설계 복잡      |
| MVI    | 상태 추적/디버깅 용이성↑      | 단방향 데이터 흐름, 불변          | 러닝커브, 코드 증가          |

이처럼 MV* 패턴들은 각자의 한계를 보완하며 진화해 왔습니다. 오늘날에는 프로젝트의 특성과 팀의 역량에 따라 이들 패턴 중 하나 또는 혼합 전략을 유연하게 선택하는 것이 일반적입니다.

## 8.5 MVC 정리
MVC는 애플리케이션을 세 가지 주요 구성 요소로 나누는 소프트웨어 아키텍처 패턴입니다.

- **모델(Model)**: 데이터와 비즈니스 로직을 담당합니다. 뷰나 컨트롤러에 대한 정보는 없으며, 데이터 변경을 알리는 메커니즘만 포함합니다.
- **뷰(View)**: 사용자에게 보여지는 UI 요소를 담당합니다. 모델의 상태를 시각적으로 표현하고, 사용자 상호작용을 컨트롤러에 전달합니다.
- **컨트롤러(Controller)**: 사용자 입력을 처리하고, 모델과 뷰 사이의 중개자 역할을 합니다.

MVC의 장점은 코드 재사용성과 관심사 분리를 통한 유지보수의 용이성입니다. 다만, 애플리케이션이 복잡해질수록 컨트롤러가 비대해지는 문제가 발생할 수 있습니다.

## 8.6 MVP 패턴
MVP(Model-View-Presenter) 패턴은 MVC에서 발전한 아키텍처로, UI와 비즈니스 로직의 분리에 중점을 둡니다.

### 8.6.1 모델, 뷰, 프리젠터
- **모델(Model)**: 데이터와 비즈니스 로직을 담당합니다.
- **뷰(View)**: UI 요소를 담당하며, 사용자 입력을 프리젠터에 전달합니다. MVP에서 뷰는 수동적이며 상태를 직접 관리하지 않습니다.
- **프리젠터(Presenter)**: 뷰와 1:1로 연결되며, 인터페이스를 통해 뷰와 상호작용합니다. 모델에서 데이터를 받아 뷰에 적합하게 가공해 전달합니다.

### 8.6.2 MVP vs MVC
- **역할과 책임**: MVC의 뷰는 모델을 직접 업데이트할 수 있지만, MVP에서는 모든 상호작용이 프리젠터를 통해 이루어집니다. MVP의 프리젠터는 보통 하나의 뷰와 연결됩니다.
- **테스트 용이성**: MVP는 뷰와 프리젠터가 인터페이스로 분리되어 있어 단위 테스트가 쉽습니다.
- **뷰의 역할**: MVC의 뷰는 모델을 직접 관찰하고 업데이트할 수 있지만, MVP의 뷰는 프리젠터의 지시에 따라 UI를 업데이트합니다.

MVP는 과거에 Android 등 모바일 플랫폼에서 많이 사용했었고, 구글이 2018년 Android Jetpack Architecture Components를 공개하며 ViewModel, LiveData, Lifecycle 관리 컴포넌트를 공식적으로 지원하기 시작하면서
MVP에서 MVVM 구조가 공식 권장 아키텍처로 자리 잡았다고 합니다.

## 8.7 MVVM 패턴
MVVM(Model-View-ViewModel)은 마이크로소프트가 WPF와 Silverlight를 위해 2005년 공식 발표한 아키텍처 패턴입니다.

- **모델(Model)**: 데이터 구조, 유효성 검사, 데이터 접근, 비즈니스 로직을 담당합니다. 뷰나 뷰모델에 대해 알지 못하며 독립적으로 동작합니다.
- **뷰(View)**: UI를 표현하며, 데이터 바인딩과 이벤트 처리만 담당합니다. 상태 관리는 하지 않고, 프레젠테이션 로직은 뷰모델에 위임합니다.
- **뷰모델(ViewModel)**: 뷰와 모델 사이의 중재자 역할을 하며, 모델 데이터를 뷰에 맞게 가공해 전달하고, 뷰의 상태와 동작을 관리합니다. 뷰와 모델을 완전히 분리해 각 계층의 독립적 개발·테스트가 가능합니다.

### 부록 - Vue.js와 MVVM
---

Vue.js를 공부하다 보면 **"Vue는 MVVM 패턴을 따른다"** 는 이야기를 종종 접하게 됩니다.  
저 역시 처음에는 여러 글과 책에서 그렇게 설명하는 것을 보고, 그대로 받아들였던 기억이 있습니다.  

하지만 이후에 공식 문서를 읽으면서, Vue는 **MVVM 패턴의 일부 개념에서 영감을 받았을 뿐**, MVVM 패턴을 **엄격하게 따르거나 강제하지는 않는다**는 사실을 알게 되었습니다.

이 오해는 Vue.js의 창시자 **Evan You(에반 유)** 가 했던 다음 발언이 자주 **오역**되면서 발생하기도 했습니다.

> "MVVM 패턴과 엄격하게 연관되어 있지는 않지만, Vue의 디자인은 부분적으로 그것의 영감을 받았다."  
> "Although not strictly associated with the MVVM pattern, Vue's design was partly inspired by it."
> — [Vue.js v2 공식 문서](https://v2.vuejs.org/v2/guide/instance.html#nav)

이 문장은 **Vue.js가 MVVM의 ViewModel 역할을 맡을 수 있다**는 의미이지,  
Vue가 **MVVM을 완전히 구현하거나 그 구조에 종속되어 있다**는 의미는 아닙니다.

실제로 에반 유는 **MVVM에서 영감을 받았다는 사실은 인정**했지만,  
Vue는 **MVVM 패턴의 규칙을 따르도록 강제하지 않으며**,  
**사용자가 컴포넌트를 설계할 때 참고할 수 있는 개념적 모델** 정도로 소개하고 있습니다.

Vue.js는 MVVM의 개념을 일부 차용했지만,  
실제로는 **대규모 애플리케이션에 더 유연하고 실용적으로 적용될 수 있도록 설계**되었습니다.

Vue 인스턴스(또는 컴포넌트)는 **View(DOM)** 와 **Model(JavaScript 객체)** 사이의 **중개자(ViewModel)** 역할을 수행하며,  
**양방향 데이터 바인딩**을 제공해 모델과 뷰를 연결합니다.

또한, 실제 DOM 조작이나 출력 형식 지정은 **디렉티브**나 **필터**로 추상화되어 있어,  
개발자는 데이터와 비즈니스 로직에 더 집중할 수 있습니다.

---

### Vue.js에서의 MVVM의 영감을 받은 구조
Vue 컴포넌트는 MVVM의 ViewModel 역할을 "비슷하게" 수행합니다. 공식적으로 MVVM을 엄격히 따르지는 않지만, 다음과 같은 구조적 유사성이 있습니다.
- **모델(Model)**: 순수 JavaScript 객체 (`data`, `props`, `reactive()`, `ref()` 등)
- **뷰(View)**: 템플릿(Template) 또는 렌더 함수로 정의된 HTML
- **뷰모델(ViewModel)**: Vue 컴포넌트 인스턴스 (데이터 바인딩과 DOM 리스너 제공)

---

### Vue의 반응형 시스템

- **단방향 데이터 바인딩**: 모델의 변화가 뷰에 자동 반영 (`{{ }}`, `v-bind`)
- **양방향 데이터 바인딩**: 뷰와 모델이 상호 업데이트 (`v-model`)

```html
<div>{{ message }}</div>
<div v-bind:title="message"></div>
<input v-model="message">
```

#### MVVM의 장점

- **관심사의 분리**: 뷰는 데이터 표현, 모델은 비즈니스 로직, 뷰모델은 중개자 역할에 집중
- **유지보수성**: 각 부분이 명확한 역할을 가져, 변경이 필요할 때 해당 부분만 수정 가능
- **생산성**: 선언적 프로그래밍으로 UI를 구성, 변경 사항이 자동으로 DOM에 반영

Vue.js는 MVVM의 원칙을 따르면서도, 대규모 애플리케이션에서는 더 유연하고 실용적인 방식을 추구합니다.

## 8.8 MVI 패턴
MVI(Model-View-Intent)는 단방향 데이터 흐름을 강조하는 UI 아키텍처로, Cycle.js 등에서 영감을 받았습니다.

MVI의 주요 구성 요소는 다음과 같습니다.
- **뷰(View)**: UI를 렌더링하며, 모델의 상태를 시각적으로 표현. 사용자 입력을 인텐트로 변환
- **인텐트(Intent)**: 사용자의 의도나 액션(버튼 클릭, 입력 등)을 나타냄

### MVI의 동작 방식

1. 사용자가 액션을 수행하면, 뷰가 이를 인텐트로 변환
2. 인텐트가 모델에 전달되어 상태 변경을 요청
3. 모델이 인텐트를 처리해 새로운 상태를 생성
4. 새로운 상태가 뷰에 전달되어 UI가 업데이트

이처럼 상태가 불변이고, 데이터가 단방향으로 흐름하기 때문에 동작이 예측 가능하고, 디버깅이 쉽습니다.

#### 장점
- 예측 가능한 상태 관리
- 상태 추적과 디버깅 용이
- 일관된 코드 구조
- 함수형 프로그래밍과의 호환성
- 테스트 용이

#### 단점
- 학습 곡선이 높을 수 있음
- 작은 변경에도 많은 코드가 필요할 수 있음
- 상태 관리를 위한 추가적인 보일러플레이트 코드 필요


## 8.9 예제

- **TodoMVC 예제**  
  [TodoMVC](https://github.com/1Marc/modern-todomvc-vanillajs)는 다양한 자바스크립트 프레임워크와 라이브러리로 할 일 목록 앱을 구현한 프로젝트입니다. 각 프레임워크의 접근 방식과 패턴을 비교하는 데 유용합니다.

## 8.10 결론

자바스크립트 MV\* 패턴은 프론트엔드 개발에서 코드 구조화와 관리를 위한 중요한 도구입니다. 각 패턴은 고유한 특성과 장단점이 있으며, 프로젝트의 요구와 팀의 선호에 따라 선택할 수 있습니다.

현대 자바스크립트 프레임워크와 라이브러리는 이러한 패턴을 다양한 방식으로 구현하며, 때로는 여러 패턴의 특성을 혼합해 사용하기도 합니다. 중요한 것은 각 패턴의 원칙을 이해하고, 애플리케이션 구조를 일관되게 유지하는 것입니다.

> 패턴은 도구일 뿐이며, 궁극적인 목표는 유지보수와 확장, 테스트가 쉬운 코드를 작성하는 것임을 잊지 맙시다!
