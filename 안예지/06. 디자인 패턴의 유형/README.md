# 6. 디자인 패턴의 유형

## 6.1 배경
- **GoF(Gang of Four)** 디자인 패턴은 크게 3가지 유형으로 분류됩니다:
  - **생성(Creational) 패턴**
  - **구조(Structural) 패턴**
  - **행위(Behavioral) 패턴**
- 각 유형은 소프트웨어 설계 시 특정 문제를 해결하는 방식에 따라 구분됩니다.

## 6.2 생성 패턴 (Creational Patterns)
- **주요 목적**: 주어진 상황에 적합한 객체를 생성하는 방법에 중점을 둠
- **핵심 개념**: 객체 생성 방식을 제어하여 유연성을 높이고 코드 재사용성을 향상시킴
- **주요 패턴**:
  - **싱글톤(Singleton)**: 클래스의 인스턴스가 하나만 생성되도록 보장
  - **팩토리 메소드(Factory Method)**: 객체 생성을 서브클래스에 위임
  - **추상 팩토리(Abstract Factory)**: 관련된 객체들의 집합을 생성
  - **빌더(Builder)**: 복잡한 객체의 생성 과정과 표현 방법을 분리
  - **프로토타입(Prototype)**: 기존 객체를 복제하여 새 객체 생성

## 6.3 구조 패턴 (Structural Patterns)
- **주요 목적**: 객체의 구성과 각 객체 간의 관계 구성 방법에 중점을 둠
- **핵심 개념**: 시스템의 한 부분이 변경되더라도 다른 부분에 영향이 가지 않도록 설계
- **주요 패턴**:
  - **어댑터(Adapter)**: 호환되지 않는 인터페이스를 함께 작동하도록 변환
  - **데코레이터(Decorator)**: 객체에 동적으로 새로운 책임 추가
  - **퍼사드(Facade)**: 복잡한 서브시스템에 대한 단순화된 인터페이스 제공
  - **프록시(Proxy)**: 다른 객체에 대한 접근을 제어하는 대리자 제공
  - **플라이웨이트(Flyweight)**: 많은 수의 유사한 객체를 효율적으로 공유

## 6.4 행위 패턴 (Behavioral Patterns)
- **주요 목적**: 시스템 내의 객체 간 커뮤니케이션 개선하거나 간소화하는 방법에 중점을 둠
- **핵심 개념**: 객체 간의 책임 분배와 알고리즘을 캡슐화하여 유연성 증대
- **주요 패턴**:
  - **옵저버(Observer)**: 객체 상태 변화 시 의존 객체들에게 자동 통지
  - **전략(Strategy)**: 알고리즘을 캡슐화하고 교체 가능하게 함
  - **커맨드(Command)**: 요청을 객체로 캡슐화하여 매개변수화 가능
  - **이터레이터(Iterator)**: 컬렉션 요소에 순차적 접근 방법 제공
  - **중재자(Mediator)**: 객체 간 상호작용을 캡슐화하여 결합도 감소
  - **템플릿 메소드(Template Method)**: 알고리즘의 구조를 정의하고 세부 단계를 서브클래스에 위임
  - **방문자(Visitor)**: 객체 구조를 변경하지 않고 새로운 연산 추가 가능

## 6.5 디자인 패턴의 분류
- 엘리스 닐슨은 2004년에 GoF 디자인 패턴 23개를 요약한 분류표를 만들었습니다.
- 이 분류는 패턴의 목적(생성, 구조, 행위)과 범위(클래스, 객체)에 따라 구분됩니다.
- 적절한 디자인 패턴을 선택하면 코드의 유지보수성, 확장성, 재사용성이 향상됩니다.

## 디자인 패턴 분류표

### 생성 패턴 (Creational Patterns)

생성 패턴은 객체 생성의 메커니즘에 초점을 둡니다.

| 패턴 | 범위 | 설명 |
|------|------|------|
| **팩토리 메서드 (Factory Method)** | 클래스 | • 인터페이스를 기반으로 여러 파생 클래스를 생성<br>• 구체적인 클래스 생성을 서브클래스에 위임 |
| **추상 팩토리 (Abstract Factory)** | 객체 | • 구체적인 내부 구현 없이 여러 클래스가 상속받아 사용하는 인스턴스를 생성<br>• 관련된 객체들의 집합을 생성하기 위한 인터페이스 제공 |
| **빌더 (Builder)** | 객체 | • 객체를 생성하는 부분과 내부 구현을 분리하여 항상 같은 객체를 생성<br>• 복잡한 객체의 생성 과정과 표현 방법을 분리 |
| **프로토타입 (Prototype)** | 객체 | • 복사 또는 복제에 사용되는 초기화된 인스턴스<br>• 기존 객체를 복제하여 새 객체 생성 |
| **싱글톤 (Singleton)** | 객체 | • 전역에서 접근 가능한 하나만의 인스턴스를 가진 클래스<br>• 클래스의 인스턴스가 하나만 생성되도록 보장 |

---

### 구조 패턴 (Structural Patterns)

구조 패턴은 클래스와 객체를 더 큰 구조로 구성하는 방법에 초점을 둡니다.

| 패턴 | 범위 | 설명 |
|------|------|------|
| **어댑터 (Adapter)** | 클래스 | • 호환되지 않는 인터페이스가 상호작용하도록 클래스를 매치<br>• 기존 클래스의 인터페이스를 클라이언트가 원하는 다른 인터페이스로 변환 |
| **브리지 (Bridge)** | 객체 | • 객체의 인터페이스와 구현을 분리하여 독립적으로 구성<br>• 추상화와 구현을 분리하여 둘 다 독립적으로 변경 가능 |
| **컴포지트 (Composite)** | 객체 | • 단순히 합친 상태 이상의 효율을 내는 간단하면서 복합적인 구조<br>• 객체들을 트리 구조로 구성하여 부분-전체 계층을 표현 |
| **데코레이터 (Decorator)** | 객체 | • 객체에 새로운 프로퍼티를 동적으로 추가<br>• 기존 객체에 새로운 기능을 동적으로 추가 |
| **퍼사드 (Facade)** | 객체 | • 전체 시스템의 복잡한 부분을 숨기는 단일 클래스<br>• 복잡한 서브시스템에 대한 단순화된 인터페이스 제공 |
| **플라이웨이트 (Flyweight)** | 객체 | • 여러 객체에 공통 상태를 공유하는 세분화된 인스턴스<br>• 많은 수의 유사한 객체를 효율적으로 공유 |
| **프록시 (Proxy)** | 객체 | • 실제 객체를 대신하는 대체 객체<br>• 다른 객체에 대한 접근을 제어하는 대리자 제공 |

---

### 행위 패턴 (Behavioral Patterns)

행위 패턴은 객체 간의 책임 할당과 알고리즘, 협력 방식에 초점을 둡니다.

| 패턴 | 범위 | 설명 |
|------|------|------|
| **인터프리터 (Interpreter)** | 클래스 | • 언어의 문장과 문법에 일치하는 언어 요소를 표현시키는 방법<br>• 특정 언어로 된 문장을 해석하는 방법을 정의 |
| **템플릿 메서드 (Template Method)** | 클래스 | • 상위 클래스에서 기본 구조를 설정한 다음 하위 클래스에서 구체적으로 정의<br>• 알고리즘의 골격을 정의하고 일부 단계를 서브클래스에 위임 |
| **책임 연쇄 (Chain of Responsibility)** | 객체 | • 요청을 처리할 수 있는 객체를 찾기 위해 체인 간에 요청을 전달<br>• 요청을 처리할 객체들의 체인을 따라 전달하는 방식 |
| **커맨드 (Command)** | 객체 | • 호출 부분과 실행 부분을 나누는 방법<br>• 요청을 객체로 캡슐화하여 매개변수화 가능 |
| **이터레이터 (Iterator)** | 객체 | • 내부 구조를 모른 채 요소에 순차적으로 접근<br>• 컬렉션의 내부 표현에 상관없이 모든 요소에 접근하는 방법을 제공 |
| **중재자 (Mediator)** | 객체 | • 클래스가 서로를 직접적으로 참조하지 않도록 중간에 간소화된 커뮤니케이션을 정의<br>• 객체 간의 상호작용을 캡슐화하여 결합도 감소 |
| **메멘토 (Memento)** | 객체 | • 나중에 복구할 수 있도록 객체의 내부 상태를 저장<br>• 객체 상태를 저장하고 나중에 복원할 수 있는 기능 제공 |
| **관찰자 (Observer)** | 객체 | • 클래스 간의 일관성을 보장하기 위해 여러 클래스에 변경사항을 알리는 방법<br>• 객체의 상태 변화를 다른 의존 객체들에게 자동으로 통지 |
| **상태 (State)** | 객체 | • 상태가 변경되면 객체의 행위도 변경<br>• 객체의 내부 상태에 따라 행동이 변경되도록 함 |
| **전략 (Strategy)** | 객체 | • 클래스 내부에 알고리즘 구현을 캡슐화하여 상황에 따른 전략과 구현을 분리<br>• 알고리즘 군을 정의하고 각각을 캡슐화하여 교체 가능하게 만듦 |
| **방문자 (Visitor)** | 객체 | • 클래스를 변경하지 않고도 새로운 작업을 추가<br>• 객체 구조를 변경하지 않고 새로운 연산을 추가할 수 있는 방법 |
