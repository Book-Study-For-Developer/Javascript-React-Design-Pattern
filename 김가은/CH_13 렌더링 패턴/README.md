# 렌더링 패턴

## 렌더링 패턴
- **클라이언트 사이드 렌더링 (CSR)**: HTML이 클라이언트에서 완전히 렌더링됨
- **서버 사이드 렌더링 (SSR)**: HTML 콘텐츠를 서버에서 동적으로 렌더링한 후, 클라이언트에서 하이드레이션함
- **정적 렌더링**: 빌드 타임에 서버에서 페이지를 렌더링하여 정적인 사이트 구축함
- **점진적 정적 생성**: 초기 빌드 이후에도 정적 사이트를 동적으로 추가하거나 수정할 수 있음 
- **스트리밍 SSR**: 서버에서 렌더링된 콘텐츠를 더 작은 스트림 조각으로 분할하여 전송함
- **엣지 렌더링**: 렌더링된 HTML을 클라이언트에 전송하기 전에 엣지에서 수정함
- **하이브리드 렌더링**: 빌드 타임, 서버 및 클라이언트 렌더링을 결합하여 웹 개발에 더 유연한 접근 방식을 제공함
- **부분 하이드레이션**: 클라이언트에서 일부 컴포넌트만 하이드레이션함
- **점진적 하이드레이션**: 클라이언트에서 컴포넌트 하이드레이션 순서를 제어함
- **아일랜드 아키텍처**: 정적인 사이트 내에 여러 진입점을 가진 동적인 동작의 격리된 영역을 만듦
- **점진적 향상**: 자바스크립트 없이도 애플리케이션이 작동하도록 보장함
> - [Rendering Patterns](https://www.patterns.dev/react/client-side-rendering/)
> - [Rendering Patterns 번역](https://patterns-dev-kr.github.io/rendering-patterns/introduction/)

<br />

## 13.1 렌더링 패턴의 중요성

### 핵심 웹 지표 (Core Web Vitals)
- **TTFB (Time to First Byte)**: 클라이언트가 페이지 콘텐츠의 첫 번째 바이트를 받는 데 걸리는 시간
- **FCP (First Contentful Paint)**: 페이지 이동 후 브라우저가 콘텐츠의 첫 부분을 렌더링하는 데 걸리는 시간
- **TTI (Time to Interactive)**: 페이지 로드 시작부터 사용자 입력에 빠르게 응답할 수 있을 때까지 걸리는 시간
- **LCP (Largest Contentful Paint)**: 페이지의 주요 콘텐츠를 로드하고 렌더링하는 데 걸리는 시간
- **CLS (Cumulative Layout Shift)**: 예상치 못한 레이아웃 변경을 방지하기 위한 시각적 안정성 측정
- **FID (First Input Delay)**: 사용자가 페이지와 상호작용한 시점부터 이벤트 핸들러가 실행될 수 있는 시점까지의 시간

> - [Core Web Vitals 최적화](https://web.dev/performance?hl=ko)
> - [Core Web Vitals를 개선하는 가장 효과적인 방법 아티클](https://web.dev/articles/top-cwv?hl=ko)
> - [Learn Performance](https://web.dev/learn/performance) - 웹 퍼포먼스를 향상시키는 여러 방법

<br />

### 개발 환경 최적화
- **빠른 빌드 시간**: 빠른 반복 작업과 배포를 위해 프로젝트는 빠르게 빌드되어야 함
- **낮은 서버 비용**: 웹사이트는 서버 실행 시간을 제한하고 최적화하여 비용을 절감해야 함
- **동적 콘텐츠**: 페이지는 동적 콘텐츠를 효율적으로 로드할 수 있어야 함
- **쉬운 롤백**: 이전 빌드 버전으로 빠르게 되돌리고 배포할 수 있어야 함
- **안정적인 가동 시간**: 운영 서버를 통해 사용자가 항상 웹사이트에 접속할 수 있어야 함
- **확장 가능한 인프라**: 성능 문제없이 프로젝트를 확장 또는 축소할 수 있어야 함

<br />

## 13.2 클라이언트 사이드 렌더링 (CSR)
- 대부분의 애플리케이션 로직이 클라이언트에서 실행되며, 데이터를 가져오거나 저장하기 위한 API 호출로 서버와 상호작용함
- 사용자가 링크를 클릭하여 탐색할 때 페이지 렌더링을 위한 새로운 요청을 서버로 보내지 않고, 클라이언트에서 코드가 실행되어 뷰나 데이터를 갈아끼움
- **페이지 새로고침 없이 탐색을 지원하는 SPA를 구축**할 수 있게 하여 뛰어난 사용자 경험 제공
- 페이지 간 라우팅이 빠르고, 반응성이 더 뛰어난 것처럼 보임
- 이미지 표시, 데이터 저장소에서 데이터 가져오기, 이벤트 처리 등 페이지의 복잡성이 증가하면 **페이지 렌더링에 필요한 자바스크립트 코드의 복잡성 증가**
- 큰 자바스크립트 번들을 만들도록 하여 페이지의 **FCP와 TTI를 증가**시킴
- 큰 요청 객체와 API 응답과 같은 일련의 네트워크 요청으로 인해, 크롤러가 색인하기 전에 의미 있는 콘텐츠가 시간에 맞춰 렌더링되지 않을 수 있어 웹사이트 **SEO에 영향**을 미칠 수 있음

<br />

### CSR과 SEO
- 구글 같은 검색 엔진은 웹 페이지를 크롤링하고, 그 안의 콘텐츠를 색인 (indexing)해서 검색 결과에 노출시킴
- 그 과정은 아래와 같은 순서로 이루어짐
  1. HTML 다운로드
  2. HTML 분석 및 링크 수집
  3. 필요시 JS 실행 (렌더링 큐에서 실행)
  4. 최종 렌더링된 콘텐츠로 색인
- **CSR 기반 앱은 초기 HTML 로딩 이후 실제 콘텐츠가 보이기까지 여러 단계의 네트워크 요청을 거쳐야 함**
- 이 단계에서 시간이 오래 걸리면, **검색 엔진의 렌더링 타이밍에 콘텐츠가 아직 로딩되지 않았을 수도 있음**

<br />

## 13.3 서버 사이드 렌더링 (SSR)
- **모든 요청마다 HTML을 생성**함
- 사용자 쿠키 정보나 요청 데이터를 기반으로 하는 등, **개인 맞춤형 데이터를 포함하는 페이지나 인증 상태에 따라 렌더링 여부를 결정해야 하는 페이지에 적합**
- 사용자 요청에 대한 응답으로 렌더링할 페이지 콘텐츠의 전체 HTML을 서버에서 생성함
- 데이터 연결 및 fetching 작업이 서버에서 처리됨 -> **데이터 fetching 및 템플릿 처리를 위한 추가적인 왕복 시간 줄일 수 있음**
- 모든 요청이 독립적으로 처리되고, 서버에 의해 새로운 요청으로 간주됨 -> 연속된 두 요청의 결과가 크게 다르지 않더라도, 서버는 처음부터 다시 처리하고 HTML을 생성함
- 핵심 원칙은 **HTML을 서버에서 렌더링하고 클라이언트에서 다시 하이드레이션하는 데 필요한 자바스크립트를 함께 제공하는 것**

<br />

### 하이드레이션
- 서버에서 HTML을 렌더링해서 클라이언트로 전달하면, 브라우저는 이미 렌더된 HTML을 받음
- 이 HTML은 정적이기 때문에 브라우저에서 이를 동적인 리액트 컴포넌트로 연결해야 함
- 하이드레이션 시 리액트는 **서버에서 렌더링된 HTML과 클라이언트에서 렌더링된 결과를 비교하고 이벤트 핸들러 등을 연결**함

<br />

### SSR에서의 하이드레이션 최적화
#### Delayed Hydration (지연 하이드레이션)
- **인터랙티브하지 않은 컴포넌트는 나중에 하이드레이션하는 방식**
- ex. 사용자가 스크롤하거나 상호작용할 때만 하이드레이션
- React에서는 `useEffect`나 [`requestIdleCallback`](https://developer.mozilla.org/ko/docs/Web/API/Window/requestIdleCallback) 사용
- Next.js에서는  `next/dynamic`을 활용한 클라이언트 사이드 렌더링 (ssr: false)과 관련 있음 (SSR에 포함되지 않아 하이드레이션 비용 줄어듦)

#### Partial Hydration (부분 하이드레이션)
- **페이지 전체가 아닌 일부 컴포넌트만 하이드레이션하는 방식**
- ex. 메뉴, 버튼 같은 일부 상호작용 영역만 하이드레이션
- 아직 리액트에서 공식 지원이 부족함

#### Selective Hydration (선택적 하이드레이션)
- React 18에서 `ReactDom.createRoot().hydrateRoot()`기반으로 특정 컴포넌트 우선 하이드레이션 가능
- ex. 사용자가 클릭한 버튼 영역만 우선 하이드레이션
- `concurrent mode`는 하이드레이션을 병렬로, 더 효율적으로 수행할 수 있게 개선됨
> - [Reactv18.0](https://react.dev/blog/2022/03/29/react-v18)

#### Streaming SSR + Incremental Hydration
- **서버에서 HTML을 스트리밍으로 보내고, 필요한 컴포넌트로부터 점진적으로 하이드레이션하는 방식**
- 클라이언트는 먼저 최소한의 UI를 받고, 나머지는 점진적으로 렌더링되고 하이드레이션됨

#### 프레임워크 레벨 캐싱과 정적 렌더링 활용
- 자주 바뀌지 않는 페이지는 SSG/ISR로 렌더링하면 하이드레이션 자체를 줄일 수 있음

<br />

## 13.4 정적 렌더링
- **전체 페이지의 HTML을 빌드 시점에 미리 생성하며, 다음 빌드 때까지 변경되지 않음**
- 정적인 HTML 콘텐츠는 **CDN이나 엣지 네트워크에 쉽게 캐싱될 수 있음**
- CDN은 클라이언트가 특정 페이지를 요청하면 미리 렌더링된 캐시된 HTML을 빠르게 제공할 수 있으며, 일반적인 SSR에 비해 페이지 요청을 처리하고, HTML 콘텐츠를 렌더링하고, 응답하는 데 걸리는 시간을 단축할 수 있음
- 자주 변경되지 않고 누가 요청하든 동일한 데이터를 표기하는 페이지에 적합

<br />

### 정적 렌더링의 변형
#### 데이터베이스의 동적 데이터를 활용한 리스트 페이지 정적 생성
- 리스트 페이지가 데이터와 함께 서버에서 생성됨
- 리스트 자체가 크게 동적이지 않은 페이지에 적합
- Next.js의 Pages router의 경우 페이지 컴포넌트 내에 `getStaticProps()` 함수를 내보내서 사용할 수 있음
- App router의 경우 fetch의 cache 옵션 사용 가능

#### 동적 경로를 사용한 상세 페이지 정적 생성
- 상품 페이지나 블로그 페이지는 보통 고정된 템플릿에 데이터를 채워 넣는 방식 사용
- 이 경우 템플릿과 동적 데이터를 병합하여 서버에서 개별 페이지를 생성할 수 있음
- Next.js의 Pages router의 경우 동적 경로 기능은 `getStaticPaths()` 함수 사용
- App router의 경우 동적 경로 기능에 `generateStaticParams()` 함수 사용 

#### 클라이언트 사이드 데이터 fetching을 통한 정적 렌더링
- 항상 최신 목록을 표시해야 하는 동적인 리스트 페이지에 유용
- 웹사이트의 UI를 뼈대 컴포넌트와 함께 정적으로 렌더링하고, 동적 목록 데이터를 배치할 위치를 미리 지정할 수 있음
- 페이지가 로드된 후 SWR을 사용하여 데이터 가져옴
- SWR: 클라이언트 사이드에서 데이터 fetching을 위한 리액트 Hook 라이브러리
- 사용자는 처음에 데이터가 없는 뼈대 UI를 보게 되고, 클라이언트는 API에서 데이터를 가져오고 응답을 받은 후 리스트 표시해야

<br />

### 정적 렌더링의 주요 특징
- HTML은 빌드 시점에 생성됨
- CDN이나 Vercel의 엣지 네트워크를 통해 쉽게 캐싱할 수 있음
- 순수 정적 렌더링은 요청 기반 데이터가 필요하지 않은 페이지에 가장 적합
- 클라이언트 사이드 데이터 fetching을 통한 정적 렌더링은 매 페이지 로드 시 새로고침되어야 하고, 안정적인 placeholder 컴포넌트에 포함된 데이터가 있는 페이지에 가장 적합

<br />

### 13.4.1 점진적 정적 생성 (ISR)
- 정적 렌더링과 SSR을 결합한 방식
- **특정 정적 페이지만 미리 렌더링하고 동적 페이지는 사용자 요청 시에 On-demand 방식으로 렌더링**
- 빌드 시간이 단축되며, 특정 시간 간격마다 캐시를 자동으로 무효화하고 페이지 다시 생성 가능
- ISR은 빌드 후 기존 정적 사이트에 점진적으로 업데이트를 적용하기 위해 두 가지 측면에서 작동함

#### 새로운 페이지 추가 허용
- 빌드 후 웹사이트에 새로운 페이지를 추가하기 위해 지연 로딩 사용
- **새로운 페이지는 첫 요청 즉시 생성**되고, 생성되는 동안 프론트엔드에서 사용자에게 대체 페이지나 로딩 화면 보여줄 수 있음

#### 기존 페이지 업데이트
- 각 페이지에 적절한 타임아웃을 정의하고, **시간이 경과할 때마다 페이지가 다시 유효한지 검증**
- 페이지 재검증이 완료될 때까지 사용자는 이전 버전의 페이지를 계속 보게 됨
- **Stale-While-Revalidate** 전략 사용 -> 캐시에 데이터가 있으면 즉시 반환, 백그라운드에서 최신 데이터 다시 요청

<br />

### 13.4.2 On-demand ISR
- **정해진 시간 간격이 아니라 특정 이벤트 발생 시에 페이지 재생성됨**
- 일반 ISR에서는 업데이트된 페이지가 해당 페이지에 대한 사용자 요청을 처리한 엣지 네트워크 노드에만 캐시됨
- On-demand ISR은 엣지 네트워크 전체에 페이지를 다시 생성하고 재분배함 -> **전 세계 사용자가 캐시된 오래된 콘텐츠가 아닌 최신 버전의 페이지를 볼 수 있음**

<br />

### 13.4.3 정적 렌더링 요약
- **순수 정적 렌더링**: 동적인 데이터가 포함되지 않은 페이지에 적합
- **클라이언트 사이드 데이터 fetching을 통한 정적 렌더링**: 매 페이지 로드 시 데이터가 새로고침되어야 하고 안정적인 placeholder 컴포넌트를 가진 페이지에 적합
- **점진적 정적 생성 (ISR)**: 특정 간격 또는 필요에 따라 재생성되어야 하는 페이지에 적합
- **On-demand ISR**: 특정 이벤트 발생 시 재생성되어야 하는 페이지에 적합

<br />

## 13.5 스트리밍 SSR
- 현재 페이지에 필요한 마크업을 모두 담은 큰 HTML 파일 하나를 생성하는 대신, **작은 조각으로 나눠서 전송**
- Node.js의 스트림 기능을 사용하면 응답 객체에 데이터를 스트리밍할 수 있음 -> **클라이언트에 데이터를 지속적으로 전송할 수 있고, 클라이언트는 데이터 조각을 받는 즉시 콘텐츠 렌더링을 시작함**
- 네트워크가 혼잡하여 더 이상 바이트를 전송할 수 없는 경우, 렌더러는 신호를 받아 네트워크가 해소될 때까지 스트리밍을 중단함 -> 서버는 메모리를 덜 사용하고 I/O가 필요한 상황에 더욱 민첩하게 반응할 수 있음

### 스트리밍 지원하는 API
- **ReactDOMServer.renderToNodeStream(element)**: 서버에서만 작동하여 HTML을 스트리밍으로 렌더링함. 이 스트리밍을 받는 클라이언트는 ReactDOM.hydrate()를 호출하여 페이지를 하이드레이션하고, 상호작용이 가능하게 만들 수 있음
- **ReactDOMServer.renderToStaticNodeStream(element)**: 서버에서 정적이고 비상호작용적인 페이지를 렌더링한 다음 클라이언트에 스트리밍하는 데 사용할 수 있음

<br />

## 13.6 엣지 SSR
- CDN의 모든 지역에서 서버 렌더링을 가능하게 하고, 콜드 부트 시간을 거의 0에 가깝게 줄여줌
- 준비되는 즉시 문서의 일부를 스트리밍하고 각 컴포넌트를 세밀하게 하이드레이션하여 FCP 시간을 단축시킴

### 활용 사례
- 사용자별로 지역 특화 리스트 페이지를 구축하는 것
- 페이지 대부분은 정적 데이터로 구성되고, 리스트 부분만 외부 요청을 통해 데이터를 가져옴
- 리스트 컴포넌트만 서버 사이드에서 렌더링하고, 나머지는 엣지 사이드에서 렌더링하도록 선택할 수 있음

<br />

## 13.7 하이브리드 렌더링
- 어떤 상황에서든 최적의 결과를 제공하기 위해 여러 가지 렌더링 방식을 결합함
- 정적으로 제공될 수 있는 페이지는 미리 렌더링하고, 다른 페이지는 동적인 전략 (ISR, SSR, CSR 및 후속 탐색을 위한 스트리밍) 선택 가능
- SPA의 틀에 갇히는 것에서 멋어나 각 페이지에 맞는 렌더링 모드를 유연하게 사용

<br />

## 13.8 점진적 하이드레이션
- **각 노드를 시간에 따라 개별적으로 하이드레이션하여 필요한 최소한의 자바스크립트만 요청하는 방식**
- 페이지의 **상대적으로 덜 중요한 부분의 하이드레이션을 지연**시켜 페이지를 상호작용할 수 있게 만드는 데 필요한 자바스크립트 양을 줄이고, 사용자에게 필요한 노드만 하이드레이션할 수 있음
- SSR에서 흔히 발생하는 서버에서 렌더링된 DOM 트리가 파괴되고 즉시 다시 생성되는 문제를 방지할 수 있음
- 애플리케이션을 여러 조각으로 나누어 뛰어난 성능을 제공하는 것을 목표로 함

<br />

### 점진적 하이드레이션 구현을 위한 요구사항
- 모든 컴포넌트에 SSR 사용 가능
- 개별 컴포넌트 또는 조각 단위로 코드 스플리팅 지원
- 개발자가 정의한 순서대로 클라이언트 사이드에서 각 조각 별 하이드레이션 지원
- 이미 하이드레이션된 조각에서 사용자 입력 가능 상태 유지
- 지연된 하이드레이션이 적용되는 조각에 로딩 중임을 표시 가능

<br />

### 리액트의 동시성 모드 (concurrent mode)
- 여러 작업을 동시에 처리하면서도 우선순위에 따라 작업 간 전환을 가능하게 함
- 작업 전환 시 부분적으로 렌더링된 트리는 진행을 잠시 멈추어, 다시 동일한 작업으로 돌아왔을 때 이전의 렌더링 작업을 계속할 수 있음
- 점진적 하이드레이션 구현에 사용 가능 -> 사용자 입력과 같은 더 높은 우선순위의 작업이 필요하면 리액트는 하이드레이션 작업을 일시 중지하고 사용자 입력을 받아들이는 작업으로 전환

<br />

## 13.9 아일랜드 아키텍처
- 정적인 HTML 위에 독립적으로 전달될 수 있는 상호작용 아일랜드를 통해 자바스크립트의 전송량을 줄이는 패러다임을 의미
- 정적과 동적 아일랜드로 구분된 페이지 뷰 제안
- 페이지의 정적인 부분은 순수하게 상호작용이 없는 정적 HTML이며 따로 하이드레이션이 필요하지 않음
- 동적인 부분은 HTML과 스크립트가 결합되어 렌더링 후 스스로 하이드레이션할 수 있는 능력을 갖추고 있음
> - [Islands Architecture](https://www.patterns.dev/vanilla/islands-architecture/)

<br />

### 아일랜드 아키텍처와 점진적 하이드레이션
- 점진적 하이드레이션에서는 페이지의 하이드레이션 구조가 하향식 -> 페이지가 개별 컴포넌트의 스케줄링 및 하이드레이션 제안
- 아일랜드 아키텍처에서는 **각 컴포넌트가 자체적으로 하이드레이션 스크립트를 가지고 있으며, 이 스크립트는 페이지의 다른 스크립트와 독립적으로 비동기 실행됨** -> 특정 컴포넌트의 성능 문제가 다른 컴포넌트에 영향을 주지 않음

<br />

### 13.9.1 아일랜드 아키텍처 구현하기
#### 아일랜드 아키텍처를 지원하는 프레임워크가 제공해야 하는 기능
- 자바스크립트 없이 서버에서 페이지를 정적으로 렌더링할 수 있어야 함
- 정적 콘텐츠 내에 자리를 마련하여 독립적인 동적 컴포넌트를 포함할 수 있어야 함. 동적 컴포넌트는 자체 스크립트를 포함하며, 메인 스레드가 여유로워지는 즉시 requestIdleCallback()을 사용하여 스스로 하이드레이션할 수 있음
- 서버에서 컴포넌트를 동형 렌더링하고 클라이언트에서 하이드레이션하여 서버와 클라이언트 양쪽에서 동일한 컴포넌트로 인식할 수 있도록 해야 함

#### 아일랜드 아키텍처를 지원하는 프레임워크
- Marko
- Astro
- Eveventy + Preact

<br />

### 13.9.2 아일랜드 아키텍처의 장점과 단점
- 성능: 상호작용이 필요한 컴포넌트에만 스크립트가 전송되므로, 전체 페이지의 가상 DOM을 다시 생성하고 모든 요소를 하이드레이션하는 데 필요한 스크립트보다 필요한 코드의 양이 훨씬 적음
- SEO: 모든 정적 콘텐츠가 서버에서 렌더링되므로 페이지는 검색 엔진 최적화에 유리함
- 중요 콘텐츠 우선순위: 블로그, 뉴스 기사 및 제품 페이지의 핵심 콘텐츠를 사용자가 즉시 볼 수 있음
- 접근성: 표준 정적 HTML 링크를 사용하여 다른 페이지에 접근하므로 웹사이트의 접근성이 향상됨
- 컴포넌트 기반: 컴포넌트 기반 아키텍처의 모든 이점 제공

<br />

## 13.10 리액트 서버 컴포넌트
- **서버에서 실행되도록 설계된, 상태를 가지지 않는 리액트 컴포넌트**
- useState, useEffect, useReducer 같은 클라이언트 전용 Hook을 사용할 수 없음
- 서버는 매 요청마다 컴포넌트를 다시 실행하므로, 영속적인 상태(state) 를 유지하지 못함
- 번들 크기를 0으로 줄이고, 서버 컴포넌트와 클라이언트 컴포넌트 사이의 매끄러운 코드 전환 경험을 가능하게 함
- 서버 컴포넌트에서 데이터를 가져오는 방법으로 async/await를 사용하여 데이터 fetching을 컴포넌트 트리의 필수적인 부분으로 통합하고, 최상위 레벨에서 await를 사용해 서버 사이드 데이터 직렬화를 가능하게 함
- 컴포넌트는 데이터를 정기적으로 다시 가져올 수 있으며, 새로운 데이터가 있을 때 다시 렌더링되는 컴포넌트를 가진 애플리케이션을 서버에서 실행할 수 있어 클라이언트로 전송해야 하는 코드 양을 줄일 수 있음
- SSR과 함께 사용하면 서버 컴포넌트 렌더링 초기 단계의 결과물을 빠르게 렌더링하고, SSR 인프라를 통해 HTML로 변환하여 초기 렌더링 속도를 빠르게 유지할 수 있음

<br />

### 13.10.1 RSC와 Nest.js App Router를 활용한 하이브리드 렌더링
- Next.js 13부터는 RSC 지원을 포함한 애플리케이션 라우터 도입 -> app 디렉토리 내 컴포넌트는 기본적으로 RSC로 설정되어 있음
- 클라이언트 컴포넌트는 클라이언트 사이드 상호작용 기능을 추가하기 위해 사용됨 -> 'use client' 지시문을 사용하여 컴포넌트를 클라이언트 컴포넌트로 선언할 수 있음
