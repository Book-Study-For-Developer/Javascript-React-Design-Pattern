# 리액트 애플리케이션 구조

## 14.1 소개
### 리액트 애플리케이션에서 파일을 그룹화하는 방법
- 기능별 그룹화: 각 애플리케이션 모듈, 기능 또는 경로별로 폴더 만듦
- 파일 유형별 그룹화: CSS, 자바스크립트, 이미지 등 파일 유형별로 폴더 만듦

<br />

### 14.1.1 모듈, 기능 또는 경로별 그룹화
- 파일 구조는 비즈니스 모델이나 애플리케이션의 흐름 반영
- 모듈에 변경사항이 있을 때 관련된 모든 파일이 같은 폴더에 모여 있어 변경사항이 특정 코드 영역으로 제한됨
- 모듈 간에 공통적으로 사용되는 컴포넌트, 로직 또는 스타일을 주기적으로 파악해야 일관성 유지 가능

<br />

### 14.1.2 파일 유형별 그룹화
- 파일 유형별로 서로 다른 폴더 생성
- 논리적으로 관련된 파일들이 파일 유형에 따라 서로 다른 폴더에 위치함

#### 장점
- 표준 구조 재사용: 여러 프로젝트에서 동일하게 사용할 수 있는 표준적인 구조 가짐
- 새로운 팀원의 빠른 적응: 애플리케이션별 로직에 대한 지식이 부족한 신규 팀원도 스타일이나 테스트 파일을 쉽게 찾을 수 있음
- 공통 컴포넌트 및 스타일 변경 용이: 여러 경로나 모듈에서 가져오는 공통 컴포넌트나 스타일을 변경하면 애플리케이션 전체에 적용됨

#### 단점
- 모듈 수정 시 여러 폴더 수정 필요: 특정 모듈의 로직을 변경하려면 여러 폴더에 있는 파일들을 찾아가 수정해야 함
- 파일 찾기 어려움: 애플리케이션의 기능이 많아질수록 각 폴더의 파일 수가 증가하여 특정 파일을 찾기 어려워짐

<br />

### 14.1.3 도메인 및 공통 컴포넌트 기반의 혼합 그룹화
- 애플리케이션 전체에서 공통적으로 사용되는 컴포넌트들을 모두 Compnents 폴더에, 애플리케이션 흐름에 특화된 경로나 기능들을 모두 domain/pages/routes 폴더에 그룹화
- 파일 유형별 그룹화외 기능별 그룹화의 장점을 모두 활용 가능
- 자주 변경되는 관련 파일들을 한 곳에 모으면서도, 애플리케이션 전체에서 공통적으로 사용되는 재사용 가능한 컴포넌트와 스타일도 함께 관리할 수 있음
- 애플리케이션의 복잡성에 따라 하위 폴더 없는 평면적인 구조 또는 더욱 중첩된 구조로 변경 가능

<br />

## 14.2 최신 리액트 기능을 위한 애플리케이션 구조
### 14.2.1 리덕스
- 공식 문서에서 특정 기능에 대한 로직을 한 곳에 모아두는 것을 강력하게 권장
- 특정 기능 폴더 내에서, 해당 기능의 리덕스 로직은 단일 슬라이스 파일로 작성되어야 하며, 가급적이면 리덕스 Toolkit의 createSlice API를 사용하는 것이 좋음
> - 단일 슬라이스 파일로 작성: 하나의 Redux 슬라이스 파일에 상태 정의 + 액션 로직 + 리듀서를 모두 몰아두자는 뜻  
> - 아래는 단일 슬라이스 파일로 작성하지 않은 예시 (분리되어 있음)  
> src/  
>├── actions/  
>│   └── todoActions.js  
>├── reducers/  
>│   └── todoReducer.js  
>├── constants/  
>│   └── todoConstants.js  

<br />

### 14.2.2 컨테이너
컴포넌트를 프레젠테이션 컴포넌트와 상태 저장 컨테이너 컴포넌트로 분류하는 방식을 사용했다면, 컨테이너 컴포넌트를 위한 별도의 폴더를 만들 수 있음

<br />

### 14.2.3 Hooks
- 모든 리액트 컴포넌트에서 사용할 수 있는 공통 Hooks를 위한 폴더를 만들어 관리할 수 있음
- 단일 컴포넌트에서만 사용되는 Hooks는 해당 컴포넌트의 파일이나 컴포넌트 폴더 내 별도의 hooks.js파일에 유지해야 함

<br />

### 14.2.4 Styled Components
컴포넌트 수준의 CSS 파일 대신 style.js 파일을 사용할 수 있음

<br />

## 14.3 기타 모범 사례
- **import aliasing 사용**: 공통 가져오기에 대한 긴 상대 경로를 줄이기 위해 사용
- **외부 라이브러리 API로 감싸기**: 외부 라이브러리의 사용을 직접적으로 컴포넌트나 로직에 드러내지 않고, 중간에 추상화 계층을 만들어 감싸는 것
- **PropTypes 사용**: 리액트 컴포넌트가 받는 props의 타입을 런타임에 검사
  ```js
  import PropTypes from 'prop-types';

  function UserCard({ name, age }) {
    return (
      <div>
        <h3>{name}</h3>
        <p>{age}살</p>
      </div>
    );
  }

  // PropTypes 정의
  UserCard.propTypes = {
    name: PropTypes.string.isRequired,
    age: PropTypes.number,
  };

  // 기본 props 설정
  UserCard.defaultProps = {
    age: 20,
  };
  ```

<br />

### 빌드 성능 개선
- 로더를 사용할 때는 변환이 필요한 모듈에만 적용
- 다른 모듈을 참조하는 import, require, define 등이 없는 파일은 noParse 옵션을 사용하여 파싱을 건너뛸 수 있음

<br />

## 14.4 Next.js 애플리케이션을 위한 애플리케이션 구조
### Pages Router (기존 방식)
- /pages 디렉토리 기반 라우팅
- 파일 이름이 URL 경로

<br />

### App Router (Next.js 13+의 새로운 방식)
- /app 디렉토리 기반 라우팅
- React Server Components 기반 (서버 렌더링)
- Layout, Template, Loading, Error 파일로 더 강력한 페이지 구성 가능
- 서버 컴포넌트에서 fetch()같은 함수 사용 가능

<br />

### Pages Router vs App Router

| 항목            | Pages Router (`pages/`)                  | App Router (`app/`)               |
| ------------- | ---------------------------------------- | --------------------------------- |
| 기본 디렉토리       | `/pages`                                 | `/app`                            |
| 서버 컴포넌트 지원    | ❌                                        | ✅                                 |
| 클라이언트 컴포넌트 구분 | ❌ (전부 클라이언트)                             | ✅ `use client` 필요                 |
| 데이터 페칭 방식     | `getServerSideProps`, `getStaticProps` 등 | 서버 컴포넌트에서 직접 fetch 가능             |
| 폴더 기반 라우팅     | ❌ 파일 기반                                  | ✅ 폴더 + 파일 기반                      |
| 페이지 레이아웃 구조화  | 제한적 (`_app.tsx`, `_document.tsx`)        | 강력한 `layout.tsx`, `template.tsx`  |
| 로딩/에러 UI      | 직접 구현 필요                                 | `loading.tsx`, `error.tsx`로 분리 가능 |

