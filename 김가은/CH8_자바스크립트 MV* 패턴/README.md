# 자바스크립트 MV*패턴

## 8.1 MVC 패턴
- 애플리케이션의 구조를 개선하기 위해 관심사의 분리를 활용하는 아키텍처 디자인 패턴

<br />

### 8.1.1 Smalltalk-80의 MVC 패턴
- 애플리케이션의 로직과 UI를 분리하는 것을 목표로 함
- 애플리케이션의 일부분을 분리함으로써 모델을 애플리케이션의 다른 인터페이스에서도 재사용할 수 있는 것이 설계의 기본 개념

#### 모델(Model)
- 도메인 관련 데이터 표현
- UI(뷰와 컨트롤러)에 관여 x
- 모델이 변경되면 자신의 관찰자 객체에게 알림 보냄

#### 뷰(View)
- 모델의 현재 상태 표현
- 관찰자 패턴을 사용해 모델이 변경되거나 수정될 때마다 뷰가 알아차릴 수 있도록 함
- 뷰는 화면에 보여지는 프레젠테이션 부분만을 담당했지만, 화면에 표시되는 각 섹션 또는 요소에는 언제나 뷰-컨트롤러 쌍 존재

#### 컨트롤러(Controller)
- 키보드 입력이나 클릭 같은 사용자의 상호작용을 처리
- 뷰에 무엇을 보여줄지, 사용자 입력을 어떻게 처리할지 결정

<br />

## 8.2 자바스크립트의 MVC

### 8.2.1 모델
- 애플리케이션의 데이터 관리
- 모델이 변경될 때 관찰자에게 변경사항 알림
- 한 가지 모델을 여러 뷰가 관찰할 수도 있음

<br />

### 8.2.2 뷰
- 모델에 대한 시각적인 표현
- 현재 상태의 특정 부분만 보여줌
- 자바스크립트의 뷰는 여러 DOM 요소의 집합을 생성하고 정리하는 역할
- 모델을 관찰하고, 모델에 변화가 생기면 알림을 받음 -> 스스로 업데이트
- 사용자와 뷰 상호작용 가능
- 뷰는 프레젠테이션 계층이기 때문에 편집과 업데이트 기능을 유저 친화적으로 제공

<br />

### 8.2.3 템플릿
- 뷰와 연관
- 템플릿은 뷰 객체의 일부 또는 전체를 선언적으로 지정하는 방법이 될 수 있음
- 태그 템플릿 리터럴과 같은 최신 템플릿 기법 사용 가능

<br />

### 8.2.4 컨트롤러
- 모델과 뷰 사이 중재자 역할
- 사용자가 뷰를 조작할 때 모델을 업데이트하는 역할
- 애플리케이션 내에서 모델과 뷰 간의 로직과 연동 관리

<br />

## 8.3 MVC를 사용하는 이유
- 전반적인 유지보수의 단순화: 애플리케이션 업데이트 시, 변경사항이 데이터 중심인지 단순한 시각적 변경인지 명확한 구분 가능
- 모델과 뷰의 분리: 비즈니스 로직에 대한 단위 테스트 작성이 간편해짐
- 애플리케이션 전반에서 하위 수준의 모델 및 컨트롤러 코드 중복 제거됨
  
<br />

## 8.6 MVP 패턴
- 프레젠테이션 로직의 개선에 초점을 맞춘 MVC 디자인 패턴의 파생

<br />

### 8.6.1 모델, 뷰, 프리젠터
- 프리젠터는 뷰에 대한 UI 비즈니스 로직을 담당하는 구성 요소
- 뷰에서의 이벤트 호출은 프리젠터로 위임됨
- 프리젠터는 뷰와 분리되어 있으며, 인터페이스를 통해 뷰와 통신
- 프리젠터는 뷰의 요청에 따라 사용자 요청과 관련된 작업을 수행하고 데이터를 뷰로 다시 전달
- 프리젠터는 데이터를 가져오고, 조작하고, 이 데이터가 어떻게 뷰에 표시되어야 하는지 결정
- MVC에서 MVP로의 변화는 애플리케이션의 테스트 용이성을 높이고 뷰와 모델 간의 분리를 더욱 명확하게 해줌
- MVP 패턴에는 데이터 바인딩이 지원되지 않음

<br />

### 8.6.2 MVP vs MVC
- MVP는 프레젠테이션 로직을 최대한 재사용해야 하는 엔터프라이즈 수준의 애플리케이션에서 사용됨
- 뷰가 매우 복잡하고 사용자와의 상호작용이 많은 애플리케이션에서는 MVC가 적합하지 않을 수 있음
- MVP의 뷰는 인터페이스를 통해 정의되고, 인터페이스가 시스템과 뷰 간의 유일한 접점 -> 개발자는 디자이너가 애플리케이션의 레이아웃과 그래픽을 완성하기 기다리지 않고도 프레젠테이션 로직 작성 가능
- MVP는 구현 방식에 따라 MVC보다 단위 테스트가 쉬울 수 있음

<br />

## 8.7 MVVM 패턴
- MVC와 MVP를 기반으로 하는 아키텍처 패턴
- 애플리케이션의 UI 개발 부분과 비즈니스 로직, 동작 부분을 명확히 분리
- 동일한 코드베이스 내에서 UI 작업과 개발 작업을 거의 동시에 진행 가능

<br />

### 8.7.2 모델
- 애플리케이션이 사용할 도메인 관련 데이터나 정보 제공
- 정보를 담고 있고, 동작을 다루지 않음
- 정보 형식을 지정하지 않고, 데이터가 브라우저에 어떻게 표현될지에 영향을 미치지 않음
- 데이터 유효성 검사 허용

<br />

### 8.7.3 뷰
- 애플리케이션에서 사용자가 상호작용하는 유일한 부분
- 뷰모델의 상태를 표현하는 상호작용이 가능한 UI
- 상태를 관리할 책임이 없음

<br />

### 8.7.4 뷰모델
- 데이터 변환기 역할을 하는 특수한 컨트롤러
- 모델의 정보를 뷰가 사용할 수 있는 형태로 변환하고, 뷰에서 발생한 명령을 모델로 전달
- 뷰의 상태를 유지하고, 뷰에서 발생한 동작에 기반해 모델을 업데이트하며, 뷰에 이벤트를 발생시키는 등의 기능을 수행하기 위한 메서드 제공 가능
- UI 계층의 뒤에 위치하며, 뷰가 필요로 하는 데이터를 제공하며, 데이터와 사용자의 동작 모두를 뷰가 참조하는 출처 역할

<br />

### 8.7.6 뷰모델 vs 모델
- 뷰모델은 모델에 대해 전적인 책임을 짐
- 뷰모델은 데이터 바인딩을 위해 모델 또는 모델의 속성을 가져올 수 있고, 뷰에 제공되는 속성을 가져오거나 조작하기 위한 인터페이스 포함 가능

<br />

## 8.9 MVC vs MVP vs MVVM

### MVC
- 뷰가 아키텍처의 최상단에 위치하고 그 옆에 컨트롤러
- 모델은 컨트롤러 아래에 있기 때문에, 뷰는 컨트롤러에 대해 알고 있고, 컨트롤러는 모델에 대해 알고 있음
- 뷰는 모델에 직접 접근 가능
- 전체 모델을 뷰에 노출하는 것은 애플리케이션의 복잡도에 따라 보안 및 성능에 문제를 일으킬 수 있음

<br />

### MVP
- 컨트롤러의 역할이 프리젠터로 대체됨
- 프리젠터는 뷰와 동일한 계층에 존재하며, 뷰와 모델 양쪽에서 발생하는 이벤트를 수신하고 이들 간 동작 조정
- 뷰와 뷰모델을 바인딩하는 메커니즘이 없기 때문에, 각 뷰는 프리젠터가 뷰와 상호작용할 수 있도록 인터페이스 구현

<br />

### MVVM
- 상태와 로직 정보를 포함할 수 있는 뷰와 관련된 모델 일부 생성 가능
- 전체 모델을 뷰에 노출하는 것을 피할 수 있음
- 뷰모델은 뷰를 참조할 필요 x
- 뷰는 뷰모델의 속성을 바인딩하여 모델에 포함된 데이터를 뷰에 표현할 수 있음

<br />

## 8.10 최신 MV* 패턴

### 8.10.1 MV* 패턴과 리액트
- 리액트를 MVC 디자인 패턴에서 사용하지 않는 이유는, 리액트에서는 서버가 브라우저에 뷰를 직접 제공하지 않고 데이터를 제공하기 때문
- 리액트의 컴포넌트는 상태(모델), 렌더링(뷰), 제어 흐름 로직(소규모의 지역화된 컨트롤러)를 담고 있는 작은 수직 분할형 MVC로 시작했다고 볼 수 있음
